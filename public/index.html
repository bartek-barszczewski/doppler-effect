<!DOCTYPE html>
<html lang="pl">

<head>
    <!-- BartÅ‚omiej Barszczewski -->
    <!-- Symulacja zjawiska fizycznego -->
    <!-- Efekt Dopplera i zjawisko stoÅ¼ka macha -->
    <!-- Semestr drugi -->
    <!-- Fizyka -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Efekt Dopplera - Symulacja">
    <title>Efekt Dopplera - Symulacja</title>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div id="control-panel" class="control-panel">
        <button class="control-btn" id="startBtn">START</button>
        <button class="control-btn" id="pauseBtn">PAUZA</button>
        <button class="control-btn" id="resetBtn">RESET</button>
        <button class="control-btn" id="show-results-btn">POKAÅ» WYNIKI</button>
    </div>

    <div id="results-modal" style="display: none;" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-btn">&times;</span>
            <h2>Wyniki i wzory</h2>
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Parametr</th>
                        <th>WartoÅ›Ä‡</th>
                        <th>WzÃ³r</th>
                    </tr>
                </thead>
                <tbody id="results-table-body"></tbody> <!-- ðŸ”§ to musi byÄ‡ -->
            </table>
        </div>
    </div>


    <div id="speedDetails" class="draggable-panel"></div>
    <div id="dopplerDetails" class="draggable-panel"></div>
    <!-- Suwaki kontrolne -->
    <div class="controls-container">
        <div class="controls" id="controls">
            <fieldset>
                <legend>Parametry ÅºrÃ³dÅ‚a dÅºwiÄ™ku</legend>

                <label for="speedControl">
                    PrÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a V [m/s]:
                    <span id="speedDisplay">343</span>
                </label>
                <div class="slider-labels">
                    <span>Min 1</span>
                    <input type="range" id="speedControl" min="1" max="8000" step="1" value="20">
                    <span>Max 8000</span>
                </div>

                <label for="frequencyControl">
                    CzÄ™stotliwoÅ›Ä‡ fali [Hz]:
                    <span id="frequencyDisplay"></span>
                </label>
                <div class="slider-labels">
                    <span>Min 20</span> <input type="range" id="frequencyControl" min="20" max="20000" step="1"
                        value="2500">
                    <span>Max 20_000</span>
                </div>
            </fieldset>
            <div class="drag-handle" id="controls-handle">:::</div>
            <div class="note">
                <p> Uwaga: <br>
                    Aktualna czÄ™stotliwoÅ›Ä‡ jest dzielona przez 1000 w celu <br> zoptymalizowani iloÅ›ci tworzenia siÄ™
                    fal.<br />
                    PrzeglÄ…darka posiada ograniczone moÅ¼liwoÅ›ci i przy ogromnej iloÅ›ci elementÃ³w (fal), moÅ¼e zachowaÄ‡
                    siÄ™ w sposÃ³b nieprzewidziany.
                </p>
            </div>
        </div>

    </div>

    <div class="container">
        <div class="line-x"></div>
        <img class="dot" id="movingDot" src="./css/img/car_yellow.png" alt="Moving source" />
        <img class="observer" id="observer1" style="left: 50%;" src="./css/img/human.png">
        <svg class="shockwaves" width="100%" height="100%">
            <line id="shockwave_upper" x1="0" y1="0" x2="0" y2="0" stroke="red" />
            <line id="shockwave_lower" x1="0" y1="0" x2="0" y2="0" stroke="red" />
        </svg>
        <!-- Skala osi X -->
        <div class="scale-x">
            <div class="scale-x-labels">
                <span style="left: 0;">-50</span>
                <span style="left: 10%;">-40</span>
                <span style="left: 20%;">-30</span>
                <span style="left: 30%;">-20</span>
                <span style="left: 40%;">-10</span>
                <span style="left: 50%;">0</span>
                <span style="left: 60%;">10</span>
                <span style="left: 70%;">20</span>
                <span style="left: 80%;">30</span>
                <span style="left: 90%;">40</span>
                <span style="left: 100%;">50</span>
            </div>
        </div>
    </div>

    <script defer>
        //================================================
        // Symulator efektu Dopplera - wyjaÅ›nienie funkcji

        /**
         * Oblicza czÄ™stotliwoÅ›Ä‡ dÅºwiÄ™ku odebranÄ… przez obserwatora
         * przy efekcie Dopplera.
         * fz â€“ czÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a [Hz]
         * v â€“ prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku [m/s]
         * vz â€“ prÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a wzglÄ™dem oÅ›rodka (dodatnia jeÅ›li zbliÅ¼a siÄ™ do obserwatora) [m/s]
         * vo â€“ prÄ™dkoÅ›Ä‡ obserwatora wzglÄ™dem oÅ›rodka (dodatnia jeÅ›li zbliÅ¼a siÄ™ do ÅºrÃ³dÅ‚a) [m/s]
         */
        const dopplerFrequencySound = (fz, v, vz, vo) => {
            // JeÅ›li prÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a >= prÄ™dkoÅ›ci fali, unikamy dzielenia przez zero lub ujemnej wartoÅ›ci
            const denom = v - vz;
            if (Math.abs(vz) >= v) {
                // Korygujemy wzÃ³r przy bardzo duÅ¼ych prÄ™dkoÅ›ciach ÅºrÃ³dÅ‚a (nadÅºwiÄ™kowych)
                return fz * ((v + vo) / Math.abs(denom));
            }
            // Klasyczny wzÃ³r Dopplera dla dÅºwiÄ™ku w powietrzu
            return fz * ((v + vo) / denom);
        };

        /**
         * Oblicza dÅ‚ugoÅ›Ä‡ fali na podstawie czÄ™stotliwoÅ›ci i prÄ™dkoÅ›ci fali.
         * fz â€“ czÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a [Hz]
         * v â€“ prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku [m/s]
         */
        const countWaveLength = (fz, v) => {
            // WzÃ³r: lambda = v / f
            return v / fz;
        };

        /**
         * Oblicza prÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a na podstawie czÄ™stotliwoÅ›ci ÅºrÃ³dÅ‚a i obserwowanej oraz prÄ™dkoÅ›ci dÅºwiÄ™ku.
         * fz â€“ czÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a [Hz]
         * fo â€“ czÄ™stotliwoÅ›Ä‡ odebrana przez obserwatora [Hz]
         * v â€“ prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku [m/s]
         */
        const velocitySource = (fz, fo, v) => {
            // WzÃ³r przeksztaÅ‚cony z klasycznego efektu Dopplera dla ruchomego ÅºrÃ³dÅ‚a
            return v * (1 - fz / fo);
        };

        /**
         * Oblicza prÄ™dkoÅ›Ä‡ obserwatora na podstawie czÄ™stotliwoÅ›ci ÅºrÃ³dÅ‚a i obserwowanej oraz prÄ™dkoÅ›ci dÅºwiÄ™ku.
         * fz â€“ czÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a [Hz]
         * fo â€“ czÄ™stotliwoÅ›Ä‡ odebrana przez obserwatora [Hz]
         * v â€“ prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku [m/s]
         */
        const velocityObserver = (fz, fo, v) => {
            // WzÃ³r przeksztaÅ‚cony z efektu Dopplera dla ruchomego obserwatora
            return v * (fo / fz - 1);
        };

        // Odtwarza dÅºwiÄ™k (np. efekt stoÅ¼ka Macha) na podstawie wskazanego pliku audio
        function playSound(url) {
            const sound = new Audio(url); // Tworzy nowy obiekt Audio z podanym adresem pliku
            sound.play();                // Uruchamia odtwarzanie dÅºwiÄ™ku (asynchronicznie)
        }

        // ======== POBRANIE ELEMENTÃ“W DOM (HTML) DO OBSÅUGI SYMULACJI ========

        // Obrazek symbolizujÄ…cy ÅºrÃ³dÅ‚o dÅºwiÄ™ku (ruchomy punkt â€“ samochÃ³d/odrzutowiec itp.)
        const movingDot = document.getElementById("movingDot");

        // GÅ‚Ã³wna kontener dla caÅ‚ej symulacji (obszar animacji)
        const container = document.querySelector(".container");

        // Suwak do ustawiania prÄ™dkoÅ›ci ÅºrÃ³dÅ‚a dÅºwiÄ™ku
        const speedControl = document.getElementById("speedControl");

        // Suwak do ustawiania czÄ™stotliwoÅ›ci dÅºwiÄ™ku
        const frequencyControl = document.getElementById("frequencyControl");

        // WyÅ›wietlanie aktualnej prÄ™dkoÅ›ci (wartoÅ›Ä‡ numeryczna przy suwaku)
        const speedDisplay = document.getElementById("speedDisplay");

        // WyÅ›wietlanie aktualnej czÄ™stotliwoÅ›ci (wartoÅ›Ä‡ numeryczna przy suwaku)
        const frequencyDisplay = document.getElementById("frequencyDisplay");

        // Panel boczny wyÅ›wietlajÄ…cy szczegÃ³Å‚y prÄ™dkoÅ›ci, liczby Macha itd.
        const speedDetails = document.getElementById("speedDetails");

        // Linie wizualizujÄ…ce stoÅ¼ek Macha (gÃ³rna i dolna krawÄ™dÅº)
        const shockwaveUpper = document.getElementById("shockwave_upper");
        const shockwaveLower = document.getElementById("shockwave_lower");

        // Obrazek obserwatora (postaÄ‡ czÅ‚owieka na osi symulacji)
        const observer = document.getElementById("observer1");

        // ======== STAÅE USTAWIENIA FIZYCZNE I SYMULACYJNE ========

        // DomyÅ›lna czÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a dÅºwiÄ™ku (Hz)
        const DEFAULT_FREQ = 400;

        // DomyÅ›lna prÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a (m/s)
        const DEFAULT_SPEED = 25;

        // PrÄ™dkoÅ›Ä‡ dÅºwiÄ™ku w powietrzu (m/s)
        const SPEED_OF_SOUND = 343;

        // Przelicznik: ile metrÃ³w przypada na 1% szerokoÅ›ci ekranu (do przeliczania pozycji)
        const METERS_PER_PERCENT = 3.43;

        // Symulowana prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku (na skalÄ™ procentowÄ… symulacji)
        const SPEED_OF_SOUND_SIM = SPEED_OF_SOUND / METERS_PER_PERCENT;

        // WspÃ³Å‚czynnik skalowania ruchu ÅºrÃ³dÅ‚a w animacji
        const SCALE_FACTOR = 1.5;

        // Czas Å¼ycia pojedynczej fali (ile sekund jest animowana)
        const WAVE_LIFETIME = 2;

        // SzerokoÅ›Ä‡ stoÅ¼ka Macha w procentach (do wizualizacji)
        const CONE_WIDTH_PERCENT = 30;

        // Minimalny odstÄ™p czasowy miÄ™dzy kolejnymi stoÅ¼kami Macha (sekundy)
        const MIN_SHOCKWAVE_INTERVAL = 5;

        // Skala czÄ™stotliwoÅ›ci (zmniejszamy czÄ™stotliwoÅ›Ä‡ do optymalizacji rysowania fal)
        const FREQUENCY_SCALE_FACTOR = 1000;

        // ======== ZMIENNE GLOBALNE - AKTUALNY STAN SYMULACJI ========

        // Pozycja obserwatora na osi X (procent kontenera, 0â€“100)
        let observerX = 50;

        // Pozycja ÅºrÃ³dÅ‚a dÅºwiÄ™ku na osi X (procent kontenera, 0â€“100)
        let sourceX = 50;

        // PrÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a (pobierana z suwaka lub domyÅ›lna)
        let speed = parseFloat(speedControl.value) || DEFAULT_SPEED;

        // CzÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a (pobierana z suwaka lub domyÅ›lna), dzielona na 100 (optymalizacja)
        let sourceFrequency = parseFloat(frequencyControl.value / 100) || DEFAULT_FREQ;

        // Ostatni moment wygenerowania fali (sekundy, do kontroli interwaÅ‚u emisji fal)
        let lastWaveTime = 0;

        // Tablica przechowujÄ…ca aktualnie animowane fale
        let waves = [];

        // Czy czÄ™stotliwoÅ›Ä‡ zostaÅ‚a ustawiona rÄ™cznie przez uÅ¼ytkownika (true/false)
        let isFrequencyManual = false;

        // Aktualny typ pojazdu/obiektu (car/ambulance/sport/jet/missile)
        let currentType = null;

        // Pozycja ÅºrÃ³dÅ‚a przy ostatnim wyemitowanym stoÅ¼ku Macha (do ograniczenia czÄ™stoÅ›ci)
        let lastShockwavePos = null;

        // Czas ostatniego wyemitowania stoÅ¼ka Macha (sekundy)
        let lastShockwaveTime = 0;

        // Ostatnio obliczona czÄ™stotliwoÅ›Ä‡ obserwowana (Doppler)
        let freqObserver = null;

        // Timeouty do obsÅ‚ugi fal odbitych (clearTimeout itd.)
        let reflectedWaveTimeouts = [];

        // Timeouty do fal odbitych w 2D
        let reflection2DTimeouts = [];

        // ======== AUDIO (generowanie dÅºwiÄ™ku w czasie rzeczywistym) ========

        // StaÅ‚a z prÄ™dkoÅ›ciÄ… dÅºwiÄ™ku (skrÃ³cona notacja)
        const c = SPEED_OF_SOUND;

        // Kontekst Web Audio API
        let audioContext = null;

        // Oscylator dÅºwiÄ™ku (generator tonu)
        let osc = null;

        // Kontrola gÅ‚oÅ›noÅ›ci dÅºwiÄ™ku
        let gain = null;

        // Oscylator LFO (np. do modulacji syreny ambulansu)
        let lfo = null;

        // Kontrola gÅ‚Ä™bokoÅ›ci modulacji LFO
        let lfoGain = null;

        // Typ aktualnie odtwarzanego dÅºwiÄ™ku (np. "car", "ambulance", itd.)
        let currentSoundType = null;

        // Typ dÅºwiÄ™ku przy poprzednim wywoÅ‚aniu (do detekcji zmiany)
        let lastEngineSoundType = null;

        // Czy symulacja jest zapauzowana
        let isPaused = false;

        function showResultsModal() {
            // Okno z tabelÄ… wynikÃ³w
            const modalResults = document.getElementById("results-modal");

            // JeÅ›li symulacja nie jest zapauzowana â€“ zamiast wynikÃ³w, miga przycisk pauzy (uÅ¼ytkownik musi najpierw zatrzymaÄ‡)
            if (!isPaused) {
                const pauseBtn = document.getElementById("pauseBtn");

                // Funkcja pomocnicza do migania kolorem przycisku "PAUZA"
                const flashColor = (bg, color, delay) => {
                    setTimeout(() => {
                        pauseBtn.style.backgroundColor = bg;
                        pauseBtn.style.color = color;
                    }, delay);
                };

                // Kilkukrotne miganie czerwonym kolorem na przycisku pauzy
                flashColor("red", "white", 0);
                flashColor("#fff", "black", 300);
                flashColor("red", "white", 600);
                flashColor("#fff", "black", 900);
                flashColor("red", "white", 1500);
                flashColor("#fff", "black", 1800);
                flashColor("red", "white", 2100);
                flashColor("#fff", "black", 2400);
                return; // KoÅ„czymy bez wyÅ›wietlania modala, dopÃ³ki nie zapauzujemy
            }

            // ===== OBLICZENIA FIZYCZNE DO WYÅšWIETLENIA WYNIKÃ“W =====

            // PrÄ™dkoÅ›Ä‡ w km/h i mph
            const kmh = speed * 3.6;
            const mph = speed * 2.23694;

            // Liczba Macha
            const mach = speed / SPEED_OF_SOUND;

            // DÅ‚ugoÅ›Ä‡ fali (lambda)
            const lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);

            // PrÄ™dkoÅ›Ä‡ wzglÄ™dna ÅºrÃ³dÅ‚a do obserwatora (waÅ¼ne dla efektu Dopplera)
            const relativeVelocity = sourceX < observerX ? speed : -speed;

            // CzÄ™stotliwoÅ›Ä‡ obserwowana przez obserwatora (efekt Dopplera)
            const freqObserverNum = dopplerFrequencySound(
                sourceFrequency, SPEED_OF_SOUND, relativeVelocity, 0
            );

            // PrzesuniÄ™cie czÄ™stotliwoÅ›ci (Doppler shift)
            const deltaF = freqObserverNum - sourceFrequency;

            // WspÃ³Å‚czynnik Dopplera (proporcja zmiany czÄ™stotliwoÅ›ci)
            const dopplerCoeff = freqObserverNum / sourceFrequency;

            // OdlegÅ‚oÅ›Ä‡ procentowa miÄ™dzy ÅºrÃ³dÅ‚em a obserwatorem (w jednostce symulacji)
            const distancePercent = Math.abs(observerX - sourceX);

            // OdlegÅ‚oÅ›Ä‡ rzeczywista w metrach (do obliczeÅ„ fizycznych)
            const distanceMeters = distancePercent * METERS_PER_PERCENT;

            // Czas dotarcia fali do obserwatora (sekundy)
            const timeToObserver = distanceMeters / SPEED_OF_SOUND;

            // PrzesuniÄ™cie fazowe fali (w radianach)
            const phaseShift = (2 * Math.PI * distanceMeters) / (lambda > 0 ? lambda : 1);

            // Energia fali przy obserwatorze (proporcjonalnie do 1/d^2)
            const energyAtObs = 1 / Math.pow(distanceMeters || 1, 2);

            // Czy dÅºwiÄ™k jest sÅ‚yszalny dla czÅ‚owieka (zakres 20-20000 Hz)
            const isAudible = sourceFrequency >= 20 && sourceFrequency <= 20000;

            // Opis poÅ‚oÅ¼enia ÅºrÃ³dÅ‚a wzglÄ™dem obserwatora
            const distanceText =
                sourceX - observerX < 0
                    ? `PRZED obserwatorem (-${distancePercent.toFixed(2)}%)`
                    : sourceX - observerX > 0
                        ? `ZA obserwatorem (+${distancePercent.toFixed(2)}%)`
                        : "Na obserwatorze (0%)";

            // Tablica wierszy do tabeli wynikÃ³w â€“ [Parametr, WartoÅ›Ä‡, WzÃ³r]
            const rows = [
                ["PrÄ™dkoÅ›Ä‡", `${speed.toFixed(2)} m/s | ${kmh.toFixed(2)} km/h | ${mph.toFixed(2)} mph`, "â€”"],
                ["Liczba Macha", mach.toFixed(2), "M = v / v_dÅºw"],
                ["CzÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a", `${sourceFrequency.toFixed(1)} Hz`, "Dana"],
                ["DÅ‚ugoÅ›Ä‡ fali", `${lambda.toFixed(2)} m`, "Î» = v_dÅºw / fâ‚€"],
                ["CzÄ™stotliwoÅ›Ä‡ obserwatora", `${freqObserverNum.toFixed(1)} Hz`, "f' = fâ‚€ Â· v_dÅºw / (v_dÅºw - v)"],
                ["KÄ…t stoÅ¼ka Macha", mach < 1 ? "â€”" : `asin(1/M)`, "sin(Î¸) = v_dÅºw / v (dla M > 1)"],
                ["OdlegÅ‚oÅ›Ä‡ od obserwatora", distanceText, "Î”x = xâ‚€ - x_obs"],
                ["Î”f (PrzesuniÄ™cie Dopplera)", `${deltaF.toFixed(2)} Hz`, "Î”f = f' - fâ‚€"],
                ["WspÃ³Å‚czynnik Dopplera", dopplerCoeff.toFixed(3), "f' / fâ‚€"],
                ["Czas dotarcia fali", `${timeToObserver.toFixed(3)} s`, "t = d / v_dÅºw"],
                ["PrzesuniÄ™cie fazowe", `${phaseShift.toFixed(2)} rad`, "Î”Ï† = 2Ï€ Â· d / Î»"],
                ["Energia wzglÄ™dna", energyAtObs.toExponential(2), "E âˆ 1 / dÂ²"],
                ["SÅ‚yszalnoÅ›Ä‡", isAudible ? "TAK" : "NIE", "fâ‚€ âˆˆ [20, 20000] Hz"],
            ];

            // Pobierz element tbody z tabeli wynikÃ³w (czyÅ›Ä‡ poprzednie wiersze)
            const tbody = document.getElementById("results-table-body");
            tbody.innerHTML = "";

            // Dodaj wszystkie wiersze do tabeli wynikÃ³w
            rows.forEach(([param, value, formula]) => {
                const row = document.createElement("tr");
                row.innerHTML = `<td>${param}</td><td>${value}</td><td>${formula}</td>`;
                tbody.appendChild(row);
            });

            modalResults.style.display = "flex";
        }

        // Funkcja uruchamiajÄ…ca dÅºwiÄ™k syreny ambulansu
        function startAmbulanceSiren() {
            // Najpierw zatrzymujemy (i czyÅ›cimy) poprzedniÄ… syrenÄ™ jeÅ›li dziaÅ‚aÅ‚a
            stopAmbulanceSiren();

            // Tworzymy nowy kontekst audio (Web Audio API)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Tworzymy oscylator bazowy â€“ generuje gÅ‚Ã³wny ton syreny
            osc = audioContext.createOscillator();
            osc.type = "square";        // Typ fali: prostokÄ…tna (wyrazisty dÅºwiÄ™k syreny)
            osc.frequency.value = 700;  // CzÄ™stotliwoÅ›Ä‡ podstawowa: 700 Hz

            // Tworzymy oscylator LFO (Low Frequency Oscillator) â€“ do modulacji czÄ™stotliwoÅ›ci (efekt "wycia" syreny)
            lfo = audioContext.createOscillator();
            lfo.type = "triangle";      // Typ fali: trÃ³jkÄ…tna (Å‚agodne przejÅ›cia)
            lfo.frequency.value = 5;    // CzÄ™stotliwoÅ›Ä‡ LFO: 5 Hz (czyli 5 razy na sekundÄ™ zmienia siÄ™ ton)

            // Tworzymy kontrolÄ™ gÅ‚Ä™bokoÅ›ci modulacji LFO (jak bardzo LFO wpÅ‚ywa na ton gÅ‚Ã³wny)
            lfoGain = audioContext.createGain();
            lfoGain.gain.value = 250;   // GÅ‚Ä™bokoÅ›Ä‡ modulacji (w Hz)

            // ÅÄ…czymy LFO z kontrolÄ… gÅ‚Ä™bokoÅ›ci
            lfo.connect(lfoGain);

            // LFO steruje czÄ™stotliwoÅ›ciÄ… oscylatora gÅ‚Ã³wnego (osc)
            lfoGain.connect(osc.frequency);

            // Tworzymy kontrolÄ™ gÅ‚oÅ›noÅ›ci
            gain = audioContext.createGain();
            gain.gain.value = 0.5;     // Bardzo cicho, Å¼eby nie ogÅ‚uszyÄ‡ uÅ¼ytkownika

            // PodÅ‚Ä…czamy oscylator do kontroli gÅ‚oÅ›noÅ›ci
            osc.connect(gain);

            // PodÅ‚Ä…czamy do wyjÅ›cia audio (gÅ‚oÅ›niki)
            gain.connect(audioContext.destination);

            // Startujemy oba oscylatory (ton gÅ‚Ã³wny i LFO)
            osc.start();
            lfo.start();
        }

        // Funkcja zatrzymujÄ…ca dÅºwiÄ™k syreny ambulansu i czyÅ›ci wszystko
        function stopAmbulanceSiren() {
            // Zatrzymanie i rozÅ‚Ä…czenie oscylatora gÅ‚Ã³wnego
            if (osc) {
                try {
                    osc.stop();
                    osc.disconnect();
                } catch (e) { }
                osc = null;
            }
            // Zatrzymanie i rozÅ‚Ä…czenie LFO
            if (lfo) {
                try {
                    lfo.stop();
                    lfo.disconnect();
                } catch (e) { }
                lfo = null;
            }
            // RozÅ‚Ä…czenie kontroli gÅ‚Ä™bokoÅ›ci LFO
            if (lfoGain) {
                try {
                    lfoGain.disconnect();
                } catch (e) { }
                lfoGain = null;
            }
            // RozÅ‚Ä…czenie kontroli gÅ‚oÅ›noÅ›ci
            if (gain) {
                try {
                    gain.disconnect();
                } catch (e) { }
                gain = null;
            }
            // Zamykanie kontekstu audio (zwalniamy zasoby)
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (e) { }
                audioContext = null;
            }
        }

        // Funkcja uruchamiajÄ…ca dÅºwiÄ™k silnika wybranego typu pojazdu (car, sport, ambulance, jet, missile itd.)
        function startEngineSound(type) {
            // JeÅ›li dÅºwiÄ™k juÅ¼ gra dla tego typu, nie rÃ³b nic (unika przeÅ‚adowaÅ„ dÅºwiÄ™ku przy niezmienionym typie)
            if (currentSoundType === type) return;

            // Zatrzymaj i wyczyÅ›Ä‡ poprzedni dÅºwiÄ™k silnika (jeÅ›li jakiÅ› graÅ‚)
            stopEngineSound();

            // Ustaw aktualny typ dÅºwiÄ™ku silnika
            currentSoundType = type;

            // JeÅ›li typ to "ambulance", uruchom dÅºwiÄ™k syreny (specjalna logika)
            if (type === "ambulance") {
                startAmbulanceSiren();
                return; // Nie tworzymy wÅ‚asnego oscylatora, bo syrena ma wÅ‚asny
            }

            // Tworzenie nowego kontekstu audio (Web Audio API)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Tworzenie oscylatora (generatora dÅºwiÄ™ku)
            osc = audioContext.createOscillator();

            // Tworzenie kontroli gÅ‚oÅ›noÅ›ci
            gain = audioContext.createGain();

            // Ustawianie typu fali i czÄ™stotliwoÅ›ci w zaleÅ¼noÅ›ci od pojazdu
            if (type === "car") {
                osc.type = "square";          // Fala prostokÄ…tna â€“ typowy, wyraÅºny dÅºwiÄ™k silnika spalinowego
                osc.frequency.value = 120;    // CzÄ™stotliwoÅ›Ä‡ podstawowa: 120 Hz
            } else if (type === "sport") {
                osc.type = "square";          // Fala prostokÄ…tna â€“ sportowy, niÅ¼szy dÅºwiÄ™k
                osc.frequency.value = 60;     // CzÄ™stotliwoÅ›Ä‡ podstawowa: 60 Hz
            } else {
                osc.type = "sine";            // Inny typ â€“ fala sinusoidalna (np. rakieta, odrzutowiec)
                osc.frequency.value = 40;     // Bardzo niski dÅºwiÄ™k
            }

            // Ustawienie gÅ‚oÅ›noÅ›ci wyjÅ›ciowej (0.5 â€“ poÅ‚owa skali)
            gain.gain.value = 0.5;

            // PodÅ‚Ä…czenie oscylatora do gain (gÅ‚oÅ›noÅ›Ä‡)
            osc.connect(gain);

            // PodÅ‚Ä…czenie gain do wyjÅ›cia audio (gÅ‚oÅ›niki)
            gain.connect(audioContext.destination);

            // RozpoczÄ™cie odtwarzania dÅºwiÄ™ku
            osc.start();
        }

        // Funkcja zatrzymujÄ…ca dÅºwiÄ™k silnika (dowolnego typu)
        function stopEngineSound() {
            // Najpierw zatrzymaj i wyczyÅ›Ä‡ syrenÄ™ ambulansu (jeÅ›li byÅ‚a aktywna)
            stopAmbulanceSiren();

            // Zatrzymanie i rozÅ‚Ä…czenie oscylatora (jeÅ›li byÅ‚ uruchomiony)
            if (osc) {
                try {
                    osc.stop();
                    osc.disconnect();
                } catch (e) { }
                osc = null;
            }

            // RozÅ‚Ä…czenie kontroli gÅ‚oÅ›noÅ›ci
            if (gain) {
                try {
                    gain.disconnect();
                } catch (e) { }
                gain = null;
            }

            // ZamkniÄ™cie kontekstu audio
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (e) { }
                audioContext = null;
            }

            // Reset typu dÅºwiÄ™ku
            currentSoundType = null;
        }

        function updateEngineSound(type, srcX, observerX, v) {
            // Zmiana typu dÅºwiÄ™ku = przeÅ‚Ä…cz silnik/syrenÄ™
            if (type !== lastEngineSoundType) {
                startEngineSound(type); // wywoÅ‚a poprawnÄ… funkcjÄ™ dla typu (w tym startAmbulanceSiren)
                lastEngineSoundType = type;
            }

            // NieobsÅ‚ugiwane typy = wyÅ‚Ä…cz audio
            if (!["car", "ambulance", "sport"].includes(type)) {
                stopEngineSound();
                return;
            }

            // ---- Dla ambulansu: tylko gÅ‚oÅ›noÅ›Ä‡ (osc, freq ustawia syrena sama) ----
            if (type === "ambulance" && gain && audioContext) {
                const percentToMeters = METERS_PER_PERCENT;
                const distance = Math.abs(srcX - observerX) * percentToMeters;
                const minDistance = 1;
                const volume = Math.min(1, 1 / Math.pow(Math.max(distance, minDistance), 2)) * 0.07; // podbij na test!
                const silenceThreshold = 40;
                const appliedVolume = distance > silenceThreshold ? 0 : volume;
                gain.gain.linearRampToValueAtTime(appliedVolume, audioContext.currentTime + 0.03);
            }

            // ---- Dla car/sport: gÅ‚oÅ›noÅ›Ä‡ + czÄ™stotliwoÅ›Ä‡ (Doppler) ----
            if ((type === "car" || type === "sport") && gain && osc && audioContext) {
                const percentToMeters = METERS_PER_PERCENT;
                const distance = Math.abs(srcX - observerX) * percentToMeters;
                const minDistance = 1;
                const volume = Math.min(1, 1 / Math.pow(Math.max(distance, minDistance), 2)) * 0.3;
                const silenceThreshold = 20;
                const appliedVolume = distance > silenceThreshold ? 0 : volume;

                let base, scale, low, high;
                if (type === "car") {
                    base = 80;
                    scale = 0.6;
                    low = 50;
                    high = 220;
                } else { // "sport"
                    base = 30;
                    scale = 0.11;
                    low = 20;
                    high = 52;
                }
                let freq = base + scale * v;
                freq = Math.max(low, Math.min(freq, high));
                const relativeVelocity = srcX < observerX ? v : -v;
                const dopplerFreq = dopplerFrequencySound(freq, SPEED_OF_SOUND, relativeVelocity, 0);
                gain.gain.linearRampToValueAtTime(appliedVolume, audioContext.currentTime + 0.02);
                osc.frequency.linearRampToValueAtTime(dopplerFreq, audioContext.currentTime + 0.02);
            }
        }


        // Aktualizuje wyÅ›wietlane wartoÅ›ci prÄ™dkoÅ›ci i czÄ™stotliwoÅ›ci w panelu sterowania
        function updateDisplays() {
            // WyÅ›wietl aktualnÄ… wartoÅ›Ä‡ prÄ™dkoÅ›ci z suwaka
            speedDisplay.textContent = speedControl.value;
            // WyÅ›wietl aktualnÄ… wartoÅ›Ä‡ czÄ™stotliwoÅ›ci z suwaka
            frequencyDisplay.textContent = frequencyControl.value;
        }

        // Aktualizuje wizualizacjÄ™ stoÅ¼ka Macha i linii uderzeniowych dla prÄ™dkoÅ›ci naddÅºwiÄ™kowych
        function updateMachConeAndLines() {
            // Pobiera pozycjÄ™ (prostokÄ…t) poruszajÄ…cego siÄ™ ÅºrÃ³dÅ‚a dÅºwiÄ™ku wzglÄ™dem okna
            const rect = movingDot.getBoundingClientRect();
            // Pobiera pozycjÄ™ kontenera, w ktÃ³rym znajduje siÄ™ ÅºrÃ³dÅ‚o
            const containerRect = container.getBoundingClientRect();
            // Korekta przesuniÄ™cia (offset), by poprawnie wycentrowaÄ‡ stoÅ¼ek wzglÄ™dem grafiki
            const adjust = -25;
            // Oblicza wspÃ³Å‚rzÄ™dnÄ… X (Å›rodek ÅºrÃ³dÅ‚a wzglÄ™dem kontenera)
            const dotX = rect.left - adjust - containerRect.left + rect.width / 2;
            // Oblicza wspÃ³Å‚rzÄ™dnÄ… Y (Å›rodek ÅºrÃ³dÅ‚a wzglÄ™dem kontenera)
            const dotY = rect.top - containerRect.top + rect.height / 2;

            // Aktualna prÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a, pobrana z suwaka
            const V = parseFloat(speedControl.value);

            // JeÅ›li prÄ™dkoÅ›Ä‡ przekracza lub rÃ³wna prÄ™dkoÅ›ci dÅºwiÄ™ku â€“ wyÅ›wietlamy stoÅ¼ek Macha
            if (V >= SPEED_OF_SOUND) {
                // Liczba Macha: ile razy prÄ™dkoÅ›Ä‡ ÅºrÃ³dÅ‚a przekracza prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku
                const M = V / SPEED_OF_SOUND;
                // Obliczamy kÄ…t stoÅ¼ka Macha (asin(1/M))
                const theta = Math.asin(1 / M);
                // Tangens tego kÄ…ta, potrzebny do wyznaczenia koÅ„cowych punktÃ³w linii
                const tanTheta = Math.tan(theta);
                // Y-owa wspÃ³Å‚rzÄ™dna koÅ„ca gÃ³rnej linii stoÅ¼ka
                const y2_upper = dotY + tanTheta * dotX;
                // Y-owa wspÃ³Å‚rzÄ™dna koÅ„ca dolnej linii stoÅ¼ka
                const y2_lower = dotY - tanTheta * dotX;

                // Ustawia poczÄ…tek i koniec gÃ³rnej linii stoÅ¼ka (SVG <line>)
                shockwaveUpper.setAttribute("x1", dotX);
                shockwaveUpper.setAttribute("y1", dotY);
                shockwaveUpper.setAttribute("x2", 0);
                shockwaveUpper.setAttribute("y2", y2_upper);

                // Ustawia poczÄ…tek i koniec dolnej linii stoÅ¼ka (SVG <line>)
                shockwaveLower.setAttribute("x1", dotX);
                shockwaveLower.setAttribute("y1", dotY);
                shockwaveLower.setAttribute("x2", 0);
                shockwaveLower.setAttribute("y2", y2_lower);

                // Pokazuje obie linie stoÅ¼ka
                shockwaveUpper.style.display = "block";
                shockwaveLower.style.display = "block";
            } else {
                // Dla prÄ™dkoÅ›ci poddÅºwiÄ™kowych ukryj stoÅ¼ek Macha
                shockwaveUpper.style.display = "none";
                shockwaveLower.style.display = "none";
            }
        }

        // Funkcja tworzy i animuje falÄ™ odbitÄ… (np. odbicie od obserwatora) w widoku 2D
        function createReflectionWave(xPosition, yPosition, amplitude = 1) {
            // 1. Tworzymy nowy element <div> â€“ to bÄ™dzie graficzna reprezentacja fali
            const wave = document.createElement("div");
            // 2. Nadajemy mu klasÄ™ CSS, ktÃ³ra ustawia odpowiedni wyglÄ…d (kolor, border, animacje)
            wave.classList.add("wave-reflected-2d");

            // 3. Specjalna obsÅ‚uga dla typu "jet" i "missile" (odrzutowiec lub pocisk naddÅºwiÄ™kowy):
            //    Fala odbita pojawia siÄ™ dokÅ‚adnie w miejscu obserwatora â€“ uÅ¼ywamy wspÃ³Å‚rzÄ™dnych pikselowych, a nie procentowych!
            if (currentType === "jet" || currentType === "missile") {
                // a) Pobieramy aktualny prostokÄ…t (pozycja, rozmiar) obserwatora wzglÄ™dem okna przeglÄ…darki
                const observerRect = observer.getBoundingClientRect();
                // b) Pobieramy pozycjÄ™ kontenera animacji (Å¼eby ustaliÄ‡ poÅ‚oÅ¼enie wzglÄ™dne)
                const containerRect = container.getBoundingClientRect();
                // c) Wyliczamy poÅ‚oÅ¼enie X Å›rodka obserwatora wzglÄ™dem kontenera (lewy brzeg + poÅ‚owa szerokoÅ›ci)
                const leftPx = observerRect.left - containerRect.left + observerRect.width / 2;
                // d) Wyliczamy poÅ‚oÅ¼enie Y Å›rodka obserwatora wzglÄ™dem kontenera (gÃ³rny brzeg + poÅ‚owa wysokoÅ›ci)
                const topPx = observerRect.top - containerRect.top + observerRect.height / 2;
                // e) Ustawiamy falÄ™ dokÅ‚adnie na Å›rodku obserwatora
                wave.style.left = `${leftPx}px`;
                wave.style.top = `${topPx}px`;
                // f) Upewniamy siÄ™, Å¼e pozycja jest absolutna (nie np. procentowa czy relatywna)
                wave.style.position = "absolute";
            } else {
                // 4. W zwykÅ‚ych przypadkach (np. samochÃ³d, ambulans) â€“ ustawiamy pozycjÄ™ na podstawie wartoÅ›ci procentowych (proporcje wzglÄ™dem szerokoÅ›ci/wysokoÅ›ci kontenera)
                wave.style.left = `${xPosition}%`;
                wave.style.top = `${yPosition}%`;
            }

            // 5. Ustawiamy przezroczystoÅ›Ä‡ fali (amplituda), np. 1 = peÅ‚na widocznoÅ›Ä‡, 0.5 = pÃ³Å‚przezroczysta
            wave.style.opacity = amplitude;
            // 6. Rozmiar poczÄ…tkowy fali (startuje jako maÅ‚e koÅ‚o)
            wave.style.width = "20px";
            wave.style.height = "20px";
            // 7. Transformacja CSS: centrowanie fali wzglÄ™dem jej Å›rodka + bardzo maÅ‚a poczÄ…tkowa skala
            wave.style.transform = "translate(-50%, -50%) scale(0.2)";
            // 8. Dodajemy falÄ™ do gÅ‚Ã³wnego kontenera animacji na scenie
            container.appendChild(wave);

            // 9. Uruchamiamy animacjÄ™ CSS (API Web Animations): powiÄ™kszanie i znikanie fali
            wave.animate(
                [
                    // a) Stan poczÄ…tkowy: maÅ‚a skala (0.2), peÅ‚na amplituda (widocznoÅ›Ä‡)
                    { transform: "translate(-50%, -50%) scale(0.2)", opacity: amplitude },
                    // b) Stan koÅ„cowy: bardzo duÅ¼a skala (10x), przezroczystoÅ›Ä‡ 0 (zanika)
                    { transform: "translate(-50%, -50%) scale(10)", opacity: 0 },
                ],
                {
                    // c) CaÅ‚a animacja trwa 1000 ms (1 sekunda)
                    duration: 1000,
                    // d) Animacja jest liniowa â€“ tempo nie przyspiesza ani nie zwalnia
                    easing: "linear"
                }
            );

            // 10. Po zakoÅ„czeniu animacji (po 1 sekundzie) â€“ usuwamy falÄ™ z DOM, Å¼eby nie zaÅ›miecaÄ‡ pamiÄ™ci i nie obciÄ…Å¼aÄ‡ przeglÄ…darki
            setTimeout(() => wave.remove(), 1000);
        }

        // Planuje (z opÃ³Åºnieniem) pojawienie siÄ™ fali odbitej od obserwatora w 2D
        function schedule2DReflection(observerPosPercent, wavePosPercent, timestamp) {
            // Obliczamy odlegÅ‚oÅ›Ä‡ (w metrach) pomiÄ™dzy miejscem fali a obserwatorem
            const distanceMeters = Math.abs(observerPosPercent - wavePosPercent) * METERS_PER_PERCENT;
            // Obliczamy ile sekund zajmie fali przebycie tej odlegÅ‚oÅ›ci z aktualnÄ… prÄ™dkoÅ›ciÄ… dÅºwiÄ™ku
            const delaySeconds = distanceMeters / SPEED_OF_SOUND;
            // Ustawiamy timeout â€“ po upÅ‚ywie wyliczonego czasu tworzymy animacjÄ™ odbitej fali
            const timeoutId = setTimeout(() => {
                // Fala odbita zawsze pojawia siÄ™ dokÅ‚adnie na pozycji obserwatora (Y=50% â€“ Å›rodek ekranu)
                createReflectionWave(observerPosPercent, 50, 1);
            }, delaySeconds * 1000);

            // ZapamiÄ™tujemy identyfikator timeoutu, by pÃ³Åºniej mÃ³c go anulowaÄ‡ jeÅ›li zajdzie taka potrzeba
            reflection2DTimeouts.push(timeoutId);
        }

        // Tworzy i animuje nowÄ… falÄ™ wychodzÄ…cÄ… od ÅºrÃ³dÅ‚a dÅºwiÄ™ku
        function createWave(xPosition, timestamp) {
            // Gdy liczba fal na ekranie przekracza 1000 â€“ usuwamy najstarszÄ…, Å¼eby nie przepeÅ‚niÄ‡ pamiÄ™ci/przeglÄ…darki
            if (waves.length > 1000) {
                const oldest = waves.shift();
                if (oldest && oldest.element) oldest.element.remove();
            }

            // Tworzymy nowy element reprezentujÄ…cy falÄ™
            const wave = document.createElement("div");
            wave.classList.add("wave"); // Nadajemy mu odpowiedniÄ… klasÄ™ CSS

            // Ustawiamy pozycjÄ™ X (procent szerokoÅ›ci kontenera)
            wave.style.left = `${xPosition}%`;
            // Pozycja Y lekko poniÅ¼ej Å›rodka (lepiej wyglÄ…da wizualnie)
            wave.style.top = "49%";
            // Obliczamy przesuniÄ™cie X (symulacja ruchu fal za poruszajÄ…cym siÄ™ ÅºrÃ³dÅ‚em)
            const translateX = -(50 + (50 * speed) / SPEED_OF_SOUND);
            wave.style.transform = `translate(${translateX}%, -50%)`;

            // Dodajemy falÄ™ do kontenera animacji
            container.appendChild(wave);

            // Obliczamy dÅ‚ugoÅ›Ä‡ fali (lambda)
            let lambda;
            try {
                lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);
            } catch (error) {
                console.error("BÅ‚Ä…d w countWaveLength:", error);
                lambda = 1; // awaryjnie ustawiamy dÅ‚ugoÅ›Ä‡ fali na 1, by uniknÄ…Ä‡ dalszych bÅ‚Ä™dÃ³w
            }

            // Animacja CSS: "rozszerzanie" fali przez zadany czas trwania
            wave.style.animation = `wave-expand ${WAVE_LIFETIME}s linear forwards`;

            // Skala koÅ„cowa animacji zaleÅ¼y od typu pojazdu (inne dla np. jet, car, sport)
            let finalScale;
            switch (currentType) {
                case "car":
                    finalScale = 30;
                    break;
                case "ambulance":
                    finalScale = 30;
                    break;
                case "sport":
                    finalScale = 30;
                    break;
                case "jet":
                case "missile":
                    if(speed < SPEED_OF_SOUND) {
                        finalScale = 50;
                    }
                    if(speed >= SPEED_OF_SOUND) {
                        finalScale = 90;
                    }
                    break;
                default:
                    finalScale = 30;
            }

            // Dodatkowa animacja (JS) dla pÅ‚ynnego przejÅ›cia skali i przezroczystoÅ›ci
            wave.animate(
                [
                    { transform: "scale(0.6)", opacity: 1 },             // poczÄ…tek: maÅ‚a, widoczna fala
                    { transform: `scale(${finalScale})`, opacity: 0 },   // koniec: duÅ¼a, przezroczysta fala
                ],
                {
                    duration: WAVE_LIFETIME * 1000,    // czas trwania (ms)
                    easing: "linear",                  // tempo liniowe
                    fill: "forwards",                  // po zakoÅ„czeniu animacji zostaje w stanie koÅ„cowym
                }
            );

            // Dodajemy nowÄ… falÄ™ do listy aktualnych fal (z metadanymi)
            waves.push({
                element: wave,
                xPosition: xPosition,
                createdAt: timestamp / 1000, // czas utworzenia (w sekundach)
            });

            // Po wygaÅ›niÄ™ciu animacji usuwamy falÄ™ z DOM oraz z listy fal (by nie zaÅ›miecaÄ‡)
            setTimeout(() => {
                wave.remove();
                waves = waves.filter((w) => w.element !== wave);
            }, WAVE_LIFETIME * 1000);

            // JeÅ›li ÅºrÃ³dÅ‚o porusza siÄ™ wolniej niÅ¼ dÅºwiÄ™k (tylko poddÅºwiÄ™kowe), rozpatrujemy odbicia fali
            if (speed < SPEED_OF_SOUND) {
                // Obliczamy dystans fali do obserwatora w metrach
                const distanceMeters = Math.abs(observerX - xPosition) * METERS_PER_PERCENT;
                // Czas dotarcia tej fali do obserwatora
                const timeToObserver = distanceMeters / SPEED_OF_SOUND;

                // JeÅ¼eli fala dotrze do obserwatora w ciÄ…gu 15% czasu Å¼ycia fali â€“ wywoÅ‚ujemy animacje odbiÄ‡
                if (timeToObserver <= WAVE_LIFETIME * 0.15) {
                    // Odbicie fali 2D â€“ efekt wizualny "na obserwatorze"
                    schedule2DReflection(observerX, xPosition, timestamp);
                    // Odbicie fali 1D/stoÅ¼kowe (bardziej zaawansowana animacja)
                    scheduleReflectedWave(observerX, xPosition, timestamp, null, false);
                }
            }
        }

        // Tworzy i animuje falÄ™ odbitÄ… (np. odbicie od obserwatora albo stoÅ¼ka Macha)
        function createReflectedWave(xPosition, timestamp, isShockwave = false, edgeX = null) {
            // JeÅ¼eli pojazd to odrzutowiec lub pocisk, to odbicie pojawia siÄ™ na pozycji obserwatora
            let leftPosition;
            let topPosition;

            if (currentType === "jet" || currentType === "missile") {
                // UÅ¼yj pozycji obserwatora
                leftPosition = observerX;
                topPosition = observer.style.top;
            } else {
                // DomyÅ›lnie: dla shockwave edgeX, w pozostaÅ‚ych przypadkach xPosition
                leftPosition = isShockwave ? edgeX : xPosition;
            }

            // Tworzymy nowy element reprezentujÄ…cy falÄ™ odbitÄ…
            const wave = document.createElement("div");
            wave.classList.add("wave-reflected"); // Nadajemy klasÄ™ odpowiedzialnÄ… za styl odbitej fali

            // JeÅ›li fala ma byÄ‡ stoÅ¼kiem Macha (shockwave)
            if (isShockwave) {
                wave.classList.add("shockwave"); // Dodatkowy styl (np. czerwona granica)
                wave.style.width = "1rem";       // Ustaw szerokoÅ›Ä‡ stoÅ¼ka Macha (rem = jednostka font-size)
                wave.style.height = "1rem";      // Ustaw wysokoÅ›Ä‡ stoÅ¼ka Macha
            }

            // Ustaw pozycjÄ™ X na wyliczonÄ… powyÅ¼ej
            wave.style.left = `${leftPosition}%`;
            // Zawsze pozycja pionowa Å›rodka
            wave.style.top = `${topPosition}`;

            // PrzesuniÄ™cie X zaleÅ¼y od tego, czy prÄ™dkoÅ›Ä‡ jest naddÅºwiÄ™kowa â€“ inny efekt dla shockwave
            const translateX =
                speed >= SPEED_OF_SOUND
                    ? -(20 + (20 * speed) / SPEED_OF_SOUND)    // dla naddÅºwiÄ™kowych â€“ mniejszy przesuw, fala bliÅ¼ej ÅºrÃ³dÅ‚a
                    : -(50 + (50 * speed) / SPEED_OF_SOUND);   // dla poddÅºwiÄ™kowych â€“ wiÄ™kszy przesuw za ÅºrÃ³dÅ‚em
            wave.style.transform = `translate(${translateX}%, -50%)`;

            // Dodaj falÄ™ do gÅ‚Ã³wnego kontenera animacji
            container.appendChild(wave);

            // Dodaj nowÄ… falÄ™ do listy aktualnych fal (przydaje siÄ™ do czyszczenia animacji)
            waves.push({
                element: wave,
                xPosition: leftPosition,
                createdAt: timestamp / 1000, // czas powstania (sekundy)
            });

            // UsuÅ„ falÄ™ z DOM i z listy fal po zakoÅ„czeniu animacji (czas Å¼ycia)
            setTimeout(() => {
                wave.remove();
                waves = waves.filter((w) => w.element !== wave);
            }, WAVE_LIFETIME * 1000);
        }



        /**
         * Planuje pojawienie siÄ™ fali odbitej (np. od obserwatora albo od stoÅ¼ka Macha) po upÅ‚ywie czasu,
         * ktÃ³ry odpowiada dotarciu fali z pozycji wavePos do pozycji observerPos przy prÄ™dkoÅ›ci dÅºwiÄ™ku.
         * - JeÅ›li to shockwave (fala stoÅ¼ka Macha) â€“ pojawia siÄ™ natychmiast (delay 0).
         * - Dla zwykÅ‚ych fal odbitych â€“ opÃ³Åºnienie zaleÅ¼ne od dystansu.
         * Tworzy timeout, po ktÃ³rym wywoÅ‚uje createReflectedWave() (rysuje odbitÄ… falÄ™ na scenie).
         * Timeout jest zapisywany do tablicy reflectedWaveTimeouts, Å¼eby pÃ³Åºniej moÅ¼na byÅ‚o go anulowaÄ‡.
         */
        function scheduleReflectedWave(observerPos, wavePos, timestamp, edgeX = null, isShockwave = false) {
            let delaySeconds;
            if (isShockwave) {
                delaySeconds = 0;
                // JeÅ›li to fala stoÅ¼ka Macha â€“ pojawia siÄ™ od razu.
            } else {
                const distanceMeters = Math.abs(observerPos - wavePos) * METERS_PER_PERCENT;
                delaySeconds = distanceMeters / SPEED_OF_SOUND;
                // Dla zwykÅ‚ej fali odbitej â€“ czekamy tyle czasu, ile zajmuje dÅºwiÄ™kowi przebycie dystansu do obserwatora.
            }
            const timeoutId = setTimeout(() => {
                createReflectedWave(observerPos, performance.now(), isShockwave, edgeX);
                // Po upÅ‚ywie czasu tworzymy odbitÄ… falÄ™ w odpowiednim miejscu.
            }, delaySeconds * 1000);
            reflectedWaveTimeouts.push(timeoutId);
            // Dodajemy identyfikator timeoutu do listy (do ewentualnego pÃ³Åºniejszego czyszczenia).
        }

        /**
         * Usuwa wszystkie zaplanowane timeouty dla odbitych fal (zarÃ³wno 1D jak i 2D) i czyÅ›ci listÄ™ timeoutÃ³w.
         * Dodatkowo usuwa wszystkie elementy fal odbitych z DOM.
         * UÅ¼ywane zawsze wtedy, gdy resetujemy symulacjÄ™, zmieniamy parametry lub czyÅ›cimy ekran.
         */
        function clearReflectedWaves() {
            reflectedWaveTimeouts.forEach((id) => clearTimeout(id));
            reflectedWaveTimeouts = [];
            // Usuwa i czyÅ›ci wszystkie timeouty zwykÅ‚ych odbitych fal.
            reflection2DTimeouts.forEach((id) => clearTimeout(id));
            reflection2DTimeouts = [];
            // Usuwa i czyÅ›ci timeouty dla odbiÄ‡ 2D.

            document.querySelectorAll(".wave-reflected, .wave-reflected-2d").forEach((el) => el.remove());
            // Usuwa wszystkie elementy odpowiadajÄ…ce odbitym falom z DOM.
        }

        // ObsÅ‚uguje zmianÄ™ prÄ™dkoÅ›ci przez suwak â€“ przepisuje prÄ™dkoÅ›Ä‡, czyÅ›ci typ pojazdu,
        // odÅ›wieÅ¼a wyÅ›wietlanie parametrÃ³w, czyÅ›ci wszystkie odbite fale i ewentualny stoÅ¼ek Macha.
        speedControl.addEventListener("input", () => {
            speed = parseFloat(speedControl.value) || 0;
            console.debug(`Nowa prÄ™dkoÅ›Ä‡: ${speed.toFixed(2)} m/s, currentType: ${currentType}`);
            currentType = null;
            updateSpeedDisplay();
            clearReflectedWaves();
            const existingCone = document.querySelector(".mach-cone");
            if (existingCone) existingCone.remove();
        });

        // ObsÅ‚uguje zmianÄ™ czÄ™stotliwoÅ›ci przez suwak â€“ ustawia flagÄ™ â€žustawiane rÄ™cznieâ€, aktualizuje wartoÅ›Ä‡,
        // odÅ›wieÅ¼a wyÅ›wietlanie parametrÃ³w i czyÅ›ci wszystkie odbite fale.
        frequencyControl.addEventListener("input", () => {
            isFrequencyManual = true;
            sourceFrequency = parseFloat(frequencyControl.value) || 1;
            updateFrequencyDisplay();
            clearReflectedWaves();
        });

        /**
         * Aktualizuje panel z dodatkowymi parametrami efektu Dopplera â€“ wyÅ›wietla szczegÃ³Å‚owe dane fizyczne
         * na podstawie aktualnych ustawieÅ„ i pozycji symulacji (np. przesuniÄ™cie czÄ™stotliwoÅ›ci, czas dotarcia fali, energia).
         * Wyniki prezentuje w elemencie HTML #dopplerDetails.
         */
        function updateDopplerDetails() {
            // Oblicza dÅ‚ugoÅ›Ä‡ fali lambda (Î» = v / f)
            let lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);

            // JeÅ›li freqObserver jest liczbÄ… (nie null) â€“ przypisz jÄ… do freqObserverNum, inaczej null
            let freqObserverNum = typeof freqObserver === "number" ? freqObserver : null;

            // Oblicza przesuniÄ™cie czÄ™stotliwoÅ›ci (Î”f = fo - fz), jeÅ›li mamy wartoÅ›Ä‡ obserwowanÄ…
            let deltaF = freqObserverNum !== null ? freqObserverNum - sourceFrequency : null;

            // Oblicza wspÃ³Å‚czynnik Dopplera (fo/fz), jeÅ›li mamy wartoÅ›Ä‡ obserwowanÄ…
            let dopplerCoeff = freqObserverNum !== null ? freqObserverNum / sourceFrequency : null;

            // Dystans procentowy (procentowa odlegÅ‚oÅ›Ä‡ na osi X miÄ™dzy obserwatorem a ÅºrÃ³dÅ‚em)
            let distancePercent = Math.abs(observerX - sourceX);

            // Przelicza dystans procentowy na metry
            let distanceMeters = distancePercent * METERS_PER_PERCENT;

            // Czas dotarcia fali do obserwatora (t = d / v)
            let timeToObserver = distanceMeters / SPEED_OF_SOUND;

            // (Zaawansowane, tylko do podglÄ…du): czas dotarcia w procentowej symulacji (uwzglÄ™dnia skalÄ™)
            let timeToObserverPercent;
            if (speed < SPEED_OF_SOUND) {
                // PoddÅºwiÄ™kowe: czas = dystans / prÄ™dkoÅ›Ä‡ symulowanego dÅºwiÄ™ku
                timeToObserverPercent = distancePercent / SPEED_OF_SOUND_SIM;
            } else {
                // NaddÅºwiÄ™kowe: uwzglÄ™dnia rÃ³Å¼nicÄ™ prÄ™dkoÅ›ci ÅºrÃ³dÅ‚a i dÅºwiÄ™ku (Å¼eby nie dzieliÄ‡ przez zero)
                const speedSim = (speed / SPEED_OF_SOUND) * SPEED_OF_SOUND_SIM;
                timeToObserverPercent = distancePercent / Math.max(speedSim - SPEED_OF_SOUND_SIM, 0.001);
            }

            // PrzesuniÄ™cie fazowe: Î”Ï† = 2Ï€ * d / Î» (w radianach)
            let phaseShift = (2 * Math.PI * distanceMeters) / (lambda > 0 ? lambda : 1);

            // Energia fali przy obserwatorze, proporcjonalnie do 1/dÂ²
            let energyAtObs = 1 / Math.pow(distanceMeters || 1, 2);

            // Czy czÄ™stotliwoÅ›Ä‡ jest sÅ‚yszalna dla czÅ‚owieka (20 Hz â€“ 20 000 Hz)
            let isAudible = sourceFrequency >= 20 && sourceFrequency <= 20000;

            // Liczba czoÅ‚owych fal na sekundÄ™ (czÄ™stotliwoÅ›Ä‡)
            let wavefrontsPerSecond = sourceFrequency;

            // WyÅ›wietla wszystko w panelu #dopplerDetails
            document.getElementById("dopplerDetails").innerHTML = `
                <b>Dodatkowe parametry:</b><br>
                PrzesuniÄ™cie Dopplera Î”f: ${deltaF !== null ? deltaF.toFixed(2) + " Hz" : "â€”"}<br>
                WspÃ³Å‚czynnik Dopplera: ${dopplerCoeff !== null ? dopplerCoeff.toFixed(3) : "â€”"}<br>
                Czas dotarcia fali: ${timeToObserver.toFixed(3)} s<br>
                PrzesuniÄ™cie fazowe: ${phaseShift.toFixed(2)} rad<br>
                Energia wzglÄ™dna: ${energyAtObs.toExponential(2)}<br>
                SÅ‚yszalnoÅ›Ä‡: ${isAudible ? "TAK" : "NIE"}<br>
            `;
        }


        /**
         * Aktualizuje panel boczny oraz wyÅ›wietlacz prÄ™dkoÅ›ci na podstawie aktualnego stanu symulacji.
         * Pokazuje podstawowe fizyczne parametry: prÄ™dkoÅ›Ä‡, liczbÄ™ Macha, czÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a, dÅ‚ugoÅ›Ä‡ fali,
         * czÄ™stotliwoÅ›Ä‡ obserwatora (z efektem Dopplera), kÄ…t stoÅ¼ka Macha (jeÅ›li prÄ™dkoÅ›Ä‡ naddÅºwiÄ™kowa)
         * oraz poÅ‚oÅ¼enie ÅºrÃ³dÅ‚a wzglÄ™dem obserwatora. Dodatkowo wywoÅ‚uje updateDopplerDetails().
         */
        function updateSpeedDisplay() {
            // Przelicza prÄ™dkoÅ›Ä‡ z m/s na km/h i mph
            const kmh = speed * 3.6;
            const mph = speed * 2.23694;
            let lambda, machAngleDeg, machAngleRad;
            try {
                // Oblicza dÅ‚ugoÅ›Ä‡ fali na podstawie czÄ™stotliwoÅ›ci i prÄ™dkoÅ›ci dÅºwiÄ™ku
                lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);

                // Oblicza liczbÄ™ Macha (ile razy prÄ™dkoÅ›Ä‡ przekracza prÄ™dkoÅ›Ä‡ dÅºwiÄ™ku)
                const mach = speed / SPEED_OF_SOUND;

                // Oblicza czÄ™stotliwoÅ›Ä‡ obserwowanÄ… z efektem Dopplera
                freqObserver = dopplerFrequencySound(
                    sourceFrequency,
                    SPEED_OF_SOUND,
                    sourceX < observerX ? speed : -speed, // znak zaleÅ¼ny od poÅ‚oÅ¼enia
                    0
                );

                // Dla prÄ™dkoÅ›ci poddÅºwiÄ™kowych nie liczymy kÄ…ta stoÅ¼ka Macha
                if (speed < SPEED_OF_SOUND) {
                    machAngleDeg = "-";
                    machAngleRad = "-";
                } else {
                    // Dla naddÅºwiÄ™kowych: oblicz kÄ…t stoÅ¼ka Macha w radianach i stopniach
                    const theta = Math.asin(SPEED_OF_SOUND / speed);
                    machAngleRad = theta;
                    machAngleDeg = theta * (180 / Math.PI);
                }

                // Oblicza dystans (procentowo) pomiÄ™dzy ÅºrÃ³dÅ‚em a obserwatorem na osi X
                const distance = sourceX - observerX;
                let distanceText;
                if (distance < 0) {
                    distanceText = `PRZED obserwatorem (${distance.toFixed(2)}%)`;
                } else if (distance > 0) {
                    distanceText = `ZA obserwatorem (+${distance.toFixed(2)}%)`;
                } else {
                    distanceText = "Na obserwatorze (0%)";
                }

                // Ustawia tekst zaktualizowanej prÄ™dkoÅ›ci w panelu
                speedDisplay.textContent = speed.toFixed(2);

                // Tworzy i wyÅ›wietla szczegÃ³Å‚owy panel z gÅ‚Ã³wnymi parametrami fizycznymi
                speedDetails.innerHTML = `
                        <b> GÅ‚Ã³wne parametry: </b><br>
                        PrÄ™dkoÅ›Ä‡: ${speed.toFixed(2)} m/s | ${kmh.toFixed(2)} km/h | ${mph.toFixed(2)} mph<br>
                        Liczba Macha: ${mach.toFixed(2)}<br>
                        CzÄ™stotliwoÅ›Ä‡ ÅºrÃ³dÅ‚a: ${sourceFrequency.toFixed(1)} Hz<br>
                        DÅ‚ugoÅ›Ä‡ fali: ${lambda.toFixed(2)} m<br>
                        CzÄ™stotliwoÅ›Ä‡ obserwatora (x=${observerX.toFixed(3)}%): ${typeof freqObserver === "number"
                        ? freqObserver.toFixed(1) + " Hz"
                        : freqObserver
                    }<br>
                        KÄ…t stoÅ¼ka Macha: ${machAngleDeg !== "-"
                        ? machAngleDeg.toFixed(2) + "Â° / " + machAngleRad.toFixed(3) + " rad"
                        : "â€” (podÅ›wietlenie dla poddÅºwiÄ™kowych)"
                    }
                        <br>
                        <b>OdlegÅ‚oÅ›Ä‡ od obserwatora: ${distanceText}</b>
                    `;

                // Aktualizuje dodatkowe szczegÃ³Å‚y Dopplera (panel poniÅ¼ej)
                updateDopplerDetails();
            } catch (error) {
                // Loguje bÅ‚Ä…d, gdyby coÅ› poszÅ‚o nie tak w obliczeniach
                console.error("BÅ‚Ä…d w updateSpeedDisplay:", error);
            }
        }


        /**
         * Aktualizuje wyÅ›wietlacz czÄ™stotliwoÅ›ci w panelu sterowania oraz odÅ›wieÅ¼a panel parametrÃ³w prÄ™dkoÅ›ci.
         * - WywoÅ‚ywana za kaÅ¼dym razem, gdy zmienisz wartoÅ›Ä‡ suwaka czÄ™stotliwoÅ›ci.
         * - Pokazuje wartoÅ›Ä‡ z dokÅ‚adnoÅ›ciÄ… do 1 miejsca po przecinku.
         * - Uwaga: rÃ³wnieÅ¼ wywoÅ‚uje updateSpeedDisplay(), wiÄ™c caÅ‚oÅ›Ä‡ panelu jest aktualizowana.
         */
        function updateFrequencyDisplay() {
            frequencyDisplay.textContent = sourceFrequency.toFixed(2);
            updateSpeedDisplay();
        }

        /**
         * Tworzy stoÅ¼ek Macha dla obiektÃ³w naddÅºwiÄ™kowych (jet/missile).
         * - Sprawdza, czy istnieje juÅ¼ stoÅ¼ek Macha w DOM (klasa .mach-cone) i usuwa go, Å¼eby nie byÅ‚o duplikatÃ³w.
         * - JeÅ¼eli prÄ™dkoÅ›Ä‡ jest poddÅºwiÄ™kowa lub typ nie jest 'jet'/'missile', funkcja koÅ„czy dziaÅ‚anie (nie rysuje stoÅ¼ka).
         * - Oblicza kÄ…t stoÅ¼ka Macha (asin(1/M)), szerokoÅ›Ä‡ oraz wysokoÅ›Ä‡ stoÅ¼ka w jednostkach procentowych.
         * - Wylicza czÄ™stotliwoÅ›Ä‡ zeskalowanÄ… (do optymalizacji), na tej podstawie okreÅ›la, jak czÄ™sto generowaÄ‡ nowe fale w stoÅ¼ku.
         * - Gdy upÅ‚ynÄ…Å‚ odpowiedni czas od ostatniej fali (zgodnie z okresowoÅ›ciÄ… czÄ™stotliwoÅ›ci), tworzy nowÄ… falÄ™ createWave().
         * - Aktualizuje znacznik czasu ostatniej generacji fali.
         */
        function createMachCone(timestamp) {
            const existingCone = document.querySelector(".mach-cone");
            if (existingCone) existingCone.remove();

            // JeÅ¼eli prÄ™dkoÅ›Ä‡ < prÄ™dkoÅ›ci dÅºwiÄ™ku lub typ to nie jet/missile â€“ nic nie rÃ³b
            if (speed < SPEED_OF_SOUND || (currentType !== "jet" && currentType !== "missile")) {
                const existingCone = document.querySelector(".mach-cone");
                if (existingCone) existingCone.remove();
                return;
            }

            // Oblicza kÄ…t stoÅ¼ka Macha (w stopniach)
            const machAngle = Math.asin(SPEED_OF_SOUND / speed) * (180 / Math.PI);

            // Ustal szerokoÅ›Ä‡ stoÅ¼ka Macha (w procentach kontenera)
            const coneWidth = CONE_WIDTH_PERCENT;
            // Wylicza wysokoÅ›Ä‡ stoÅ¼ka (geometria trÃ³jkÄ…ta na podstawie kÄ…ta)
            const coneHeight = Math.tan(machAngle * (Math.PI / 180)) * (coneWidth / 2);

            // Zeskalowana czÄ™stotliwoÅ›Ä‡ (w symulacji liczba fal jest mniejsza niÅ¼ w rzeczywistoÅ›ci)
            const scaledFrequency = sourceFrequency / FREQUENCY_SCALE_FACTOR;
            // Oblicza okres generowania fal na podstawie zeskalowanej czÄ™stotliwoÅ›ci
            const period = 1 / scaledFrequency;
            // JeÅ›li minÄ…Å‚ odpowiedni czas od ostatniej fali, generuje nowÄ… falÄ™ (symulacja emisji przez odrzutowiec)
            if (timestamp / 1000 - lastWaveTime >= period) {
                createWave(sourceX, timestamp);
                lastWaveTime = timestamp / 1000;
            }
        }

        /**
         * Tworzy tymczasowy znacznik (marker) na osi symulacji w celu debugowania.
         * - SÅ‚uÅ¼y do podÅ›wietlania konkretnej pozycji na osi X (np. krawÄ™dÅº stoÅ¼ka Macha, miejsce wykrycia czegoÅ› waÅ¼nego).
         * - Zawsze pojawia siÄ™ dokÅ‚adnie na podanej pozycji procentowej xPosition oraz na Å›rodku osi Y (50%).
         * - Marker automatycznie znika po 1 sekundzie.
         */
        function createDebugMarker(xPosition) {
            // Usuwa poprzedni marker, jeÅ›li jeszcze istnieje, Å¼eby nie byÅ‚o wiÄ™cej niÅ¼ jednego naraz
            const existingMarker = document.querySelector(".debug-marker");
            if (existingMarker) existingMarker.remove();

            // Tworzy nowy znacznik <div> i nadaje mu klasÄ™ do stylowania (np. czerwona kropka)
            const marker = document.createElement("div");
            marker.classList.add("debug-marker");

            // Ustawia pozycjÄ™ markera na osi X (procent kontenera) oraz na Å›rodku osi Y (50%)
            marker.style.left = `${xPosition}%`;
            marker.style.top = "50%";
            marker.style.transform = "translate(-50%, -50%)"; // WyÅ›rodkowanie markera wzglÄ™dem punktu

            // Dodaje znacznik do kontenera symulacji (gÅ‚Ã³wnego obszaru animacji)
            container.appendChild(marker);

            // Po 1 sekundzie usuwa marker z DOM, Å¼eby nie zostawaÅ‚y Å›mieci i nie zaÅ›miecaÅ‚y ekranu
            setTimeout(() => {
                marker.remove();
            }, 1000);
        }

        /**
         * GÅ‚Ã³wna pÄ™tla animacji symulacji.
         * - Przesuwa ÅºrÃ³dÅ‚o dÅºwiÄ™ku (pojazd) na osi X.
         * - PrzeÅ‚Ä…cza typ pojazdu na podstawie prÄ™dkoÅ›ci.
         * - Dostosowuje grafiki, parametry i dÅºwiÄ™ki dla danego typu.
         * - Tworzy i animuje fale oraz stoÅ¼ki Macha.
         * - WywoÅ‚uje odtwarzanie dÅºwiÄ™kÃ³w specjalnych (np. szokowy, jet).
         * - Aktualizuje wszystkie wizualizacje i parametry na ekranie.
         */
        function update(timestamp) {
            // JeÅ›li symulacja jest zapauzowana, przerywamy pÄ™tlÄ™
            if (isPaused) return;

            // ---- 1. Ruch ÅºrÃ³dÅ‚a dÅºwiÄ™ku po osi X ----
            const deltaTime = 0.016; // StaÅ‚a przyrostu czasu (ok. 60 klatek/s)
            // Przesuwamy ÅºrÃ³dÅ‚o proporcjonalnie do prÄ™dkoÅ›ci
            sourceX += (speed / SPEED_OF_SOUND) * deltaTime * 10 * SCALE_FACTOR;
            // JeÅ›li dotarliÅ›my do koÅ„ca skali (100%), zawijamy do poczÄ…tku (pÄ™tla)
            if (sourceX > 100) {
                sourceX -= 100;
                lastShockwavePos = null;
                lastShockwaveTime = 0;
            }

            // Aktualizujemy pozycjÄ™ obrazka pojazdu na osi X
            if (movingDot) {
                movingDot.style.left = `${sourceX}%`;
            }

            // ---- 2. Wybieramy typ pojazdu na podstawie prÄ™dkoÅ›ci ----
            const isCarSpeed = speed <= 20;
            const isAmbulance = speed > 20 && speed <= 39;
            const isCarSport = speed > 50 && speed <= 117;
            const isJet = speed > 117 && speed < 664;
            const isMissile = speed >= 664;

            let newType = null;
            // Ustawiamy typ pojazdu, tÅ‚o, pozycjÄ™ i rozmiar obserwatora
            if (isCarSpeed) {
                // SamochÃ³d
                document.body.style.backgroundImage = "url('./css/img/arizona_road.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundPosition = "0px -280px";
                document.body.style.backgroundColor = "#e6a142";
                newType = "car";
                observer.style.top = "45%";
                observer.style.height = "80px";
            } else if (isAmbulance) {
                // Ambulans
                document.body.style.backgroundImage = "url('./css/img/arizona_road.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundPosition = "0px -280px";
                document.body.style.backgroundColor = "#e6a142";
                newType = "ambulance";
                observer.style.top = "45%";
                observer.style.height = "80px";
            } else if (isCarSport) {
                // SamochÃ³d sportowy
                document.body.style.backgroundImage = "url('./css/img/arizona_road.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundPosition = "0px -280px";
                document.body.style.backgroundColor = "#e6a142";
                newType = "sport";
                observer.style.top = "45%";
                observer.style.height = "80px";
            } else if (isJet) {
                // Odrzutowiec
                document.body.style.backgroundImage = "url('./css/img/sky.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundPosition = "0px 180px";
                document.body.style.backgroundColor = "rgb(193, 255, 244)";
                newType = "jet";
                observer.style.top = "72%";
                observer.style.height = "35px";
            } else if (isMissile) {
                // Pocisk
                document.body.style.backgroundImage = "url('./css/img/sky.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundPosition = "0px 180px";
                document.body.style.backgroundColor = "rgb(193, 255, 244)";
                newType = "missile";
                observer.style.top = "72%";
                observer.style.height = "35px";
            }

            // ---- 3. JeÅ›li zmieniÅ‚ siÄ™ typ pojazdu: aktualizujemy grafiki i domyÅ›lnÄ… czÄ™stotliwoÅ›Ä‡ ----
            if (newType !== currentType) {
                currentType = newType;

                if (newType === "car") {
                    movingDot.src = "./css/img/car_yellow.png";
                    observer.src = "./css/img/human.png";
                    movingDot.style.transform = `translate(-50%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 2500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "ambulance") {
                    movingDot.src = "./css/img/ambulance.png";
                    observer.src = "./css/img/nurse.png";
                    movingDot.style.transform = `translate(-50%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 2500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "sport") {
                    movingDot.src = "./css/img/bugatti_chiron.png";
                    observer.src = "./css/img/human.png";
                    movingDot.style.transform = `translate(-75%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 3500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "jet") {
                    movingDot.src = "./css/img/jet.png";
                    observer.src = "./css/img/human.png";
                    movingDot.style.transform = `translate(-100%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 4500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "missile") {
                    observer.src = "./css/img/human.png";
                    movingDot.src = "./css/img/missle.png";
                    movingDot.style.transform = `translate(-100%, -50%)`;
                }

                // Aktualizacja wyÅ›wietlanej czÄ™stotliwoÅ›ci
                updateFrequencyDisplay();
            }

            // ---- 4. Tworzenie fal (dla poddÅºwiÄ™kowych) ----
            const scaledFrequency = sourceFrequency / FREQUENCY_SCALE_FACTOR;
            const period = 1 / scaledFrequency;
            if (speed < SPEED_OF_SOUND && timestamp / 1000 - lastWaveTime >= period) {
                createWave(sourceX, timestamp);
                lastWaveTime = timestamp / 1000;
            }

            // ---- 5. StoÅ¼ek Macha, dÅºwiÄ™k szokowy i marker na krawÄ™dzi stoÅ¼ka (dla naddÅºwiÄ™kowych jet/missile) ----
            const waveWidthPx = 0.95 * parseFloat(getComputedStyle(document.documentElement).fontSize);
            const proximityThreshold = (waveWidthPx / (container.clientWidth || 1000)) * 100 * 5;

            if (speed >= SPEED_OF_SOUND && (currentType === "jet" || currentType === "missile")) {
                // Zmieniamy szerokoÅ›Ä‡ grafiki samolotu
                movingDot.style.width = `220px`;
                movingDot.style.transform = `translate(-50%, -50%)`;

                // Obliczamy kÄ…t i krawÄ™dÅº stoÅ¼ka Macha
                const machAngle = Math.asin(SPEED_OF_SOUND / speed);
                const coneWidthPercent = CONE_WIDTH_PERCENT;
                const edgeX = sourceX - coneWidthPercent * Math.cos(machAngle);
                createDebugMarker(edgeX); // Zaznaczamy miejsce krawÄ™dzi stoÅ¼ka

                // Warunki na "uderzenie" stoÅ¼ka w obserwatora
                const shockThreshold = coneWidthPercent / 2;
                const currentTime = timestamp / 1000;
                const isConeEdgeAtObserver =
                    Math.abs(observerX - edgeX) < proximityThreshold &&
                    (!lastShockwavePos || Math.abs(sourceX - lastShockwavePos) > shockThreshold) &&
                    currentTime - lastShockwaveTime > MIN_SHOCKWAVE_INTERVAL;

                createMachCone(timestamp);      // Rysuje stoÅ¼ek Mach'a
                updateMachConeAndLines();       // Aktualizuje linie graficzne stoÅ¼ka

                // Efekt dÅºwiÄ™kowy i fala szokowa
                if (isConeEdgeAtObserver) {
                    scheduleReflectedWave(observerX, sourceX, timestamp, edgeX, true);
                    lastShockwavePos = sourceX;
                    lastShockwaveTime = currentTime;
                    playSound("./sounds/shockwave.mp3");
                }
            }

            // ---- 6. Odtwarzanie dÅºwiÄ™ku jet (ponaddÅºwiÄ™kowy i poddÅºwiÄ™kowy) ----
            // Dla jet: gdy znajduje siÄ™ dokÅ‚adnie -30% przed obserwatorem i jeszcze nie przekroczyÅ‚ dÅºwiÄ™ku
            if (
                currentType === "jet" &&
                Math.abs(sourceX - (observerX - 30)) < 0.5 && // maÅ‚y margines, animacja nie jest "skokowa"
                speed < SPEED_OF_SOUND
            ) {
                if (!window.jetSoundPlayed) { // Zapobiega wielokrotnemu odtwarzaniu
                    playSound("./sounds/jet.mp3");
                    window.jetSoundPlayed = true;
                }
            } else if (window.jetSoundPlayed) {
                window.jetSoundPlayed = false; // Reset, jeÅ›li jet oddali siÄ™ od tej pozycji
            }

            // Dla jet: gdy dokÅ‚adnie na obserwatorze (dla naddÅºwiÄ™kowego) â€”Â moÅ¼esz zmieniÄ‡ warunek wg uznania
            if (
                currentType === "jet" &&
                Math.abs(sourceX - (observerX)) < 0.5 &&
                speed >= SPEED_OF_SOUND
            ) {
                if (!window.jetSoundPlayed) {
                    playSound("./sounds/jet.mp3");
                    window.jetSoundPlayed = true;
                }
            } else if (window.jetSoundPlayed) {
                window.jetSoundPlayed = false;
            }

            // ---- 7. Kontynuacja pÄ™tli animacji ----
            requestAnimationFrame(update); // WywoÅ‚uje kolejnÄ… klatkÄ™

            // ---- 8. Aktualizacje wizualizacji i dÅºwiÄ™ku silnika ----
            updateMachConeAndLines();
            updateSpeedDisplay();
            updateEngineSound(currentType, sourceX, observerX, speed);

        }

        /**
         * Funkcja makePanelDraggable(panel, handle)
         * UmoÅ¼liwia przeciÄ…ganie dowolnego panelu (np. bocznego okienka z wynikami) po ekranie
         * poprzez klikniÄ™cie i przeciÄ…gniÄ™cie za okreÅ›lony uchwyt (handle).
         * 
         * - panel: element DOM, ktÃ³ry chcemy przesuwaÄ‡ po ekranie
         * - handle: element DOM, ktÃ³ry sÅ‚uÅ¼y jako uchwyt do przeciÄ…gania panelu
         * 
         * Po klikniÄ™ciu uchwytu (handle), panel Å›ledzi ruchy myszy
         * i zmienia swoje poÅ‚oÅ¼enie na ekranie, dopÃ³ki nie puszczymy przycisku myszy.
         */

        function makePanelDraggable(panel, handle) {
            // Pozycja kursora wzglÄ™dem panelu przy rozpoczÄ™ciu przeciÄ…gania
            let offsetX = 0,
                offsetY = 0,
                isDown = false; // Czy aktualnie przeciÄ…gamy panel

            // Gdy uÅ¼ytkownik kliknie uchwyt (handle), zapamiÄ™taj, gdzie kliknÄ…Å‚ wzglÄ™dem panelu
            handle.addEventListener("mousedown", function (e) {
                isDown = true;
                offsetX = e.clientX - panel.offsetLeft;
                offsetY = e.clientY - panel.offsetTop;
                document.body.style.cursor = "grabbing"; // Wizualny efekt chwytania
                e.preventDefault(); // Nie zaznaczaj tekstu itp.
            });

            // Gdy uÅ¼ytkownik porusza myszÄ…, a panel jest "zÅ‚apany" (isDown), przesuwaj panel zgodnie z ruchem myszy
            document.addEventListener("mousemove", function (e) {
                if (!isDown) return; // Nie przesuwaj, jeÅ›li nie trzymamy myszy
                panel.style.left = e.clientX - offsetX + "px"; // Nowa pozycja X panelu
                panel.style.top = e.clientY - offsetY + "px";  // Nowa pozycja Y panelu
            });

            // Po puszczeniu przycisku myszy przestaÅ„ przeciÄ…gaÄ‡ panel
            document.addEventListener("mouseup", function () {
                isDown = false;
                document.body.style.cursor = ""; // PrzywrÃ³Ä‡ domyÅ›lny kursor
            });
        }

        // Ten blok kodu wykonuje siÄ™, gdy caÅ‚a zawartoÅ›Ä‡ DOM (HTML) jest juÅ¼ wczytana i gotowa do pracy
        window.addEventListener("DOMContentLoaded", () => {

            // ObsÅ‚uga przycisku "START" â€“Â wznowienie animacji
            document.getElementById("startBtn").addEventListener("click", () => {
                if (isPaused) {
                    isPaused = false;                  // Zmienna globalna: czy symulacja zatrzymana
                    requestAnimationFrame(update);     // Wznawia gÅ‚Ã³wnÄ… pÄ™tlÄ™ animacji
                }
            });

            // ObsÅ‚uga przycisku "PAUZA" â€“ zatrzymanie animacji (nie usuwa stanu)
            document.getElementById("pauseBtn").addEventListener("click", () => {
                isPaused = true;
            });

            // ObsÅ‚uga przycisku "RESET" â€“ przeÅ‚adowanie strony (reset wszystkiego do stanu poczÄ…tkowego)
            document.getElementById("resetBtn").addEventListener("click", () => {
                location.reload();
            });

            // Ustaw pozycjÄ™ obserwatora (postaÄ‡ czÅ‚owieka) na osi symulacji na start (50%)
            observer.style.left = observerX + "%";

            // Zaktualizuj wyÅ›wietlane wartoÅ›ci prÄ™dkoÅ›ci i czÄ™stotliwoÅ›ci na panelu
            updateDisplays();

            // Dodaj event listener do suwaka prÄ™dkoÅ›ci â€“ aktualizuje wartoÅ›ci na panelu
            speedControl.addEventListener("input", updateDisplays);
            // Dodaj event listener do suwaka czÄ™stotliwoÅ›ci â€“ to samo
            frequencyControl.addEventListener("input", updateDisplays);

            // Od razu zaktualizuj panele ze szczegÃ³Å‚ami
            updateSpeedDisplay();
            updateFrequencyDisplay();
            requestAnimationFrame(update); // Rozpocznij gÅ‚Ã³wnÄ… animacjÄ™ od razu po starcie
            updateEngineSound(currentType, sourceX, observerX, speed);

            // --- PoniÅ¼ej obsÅ‚uga przeciÄ…gania ÅºrÃ³dÅ‚a dÅºwiÄ™ku (movingDot â€“ samochÃ³d, samolot, itp.) ---

            let isDragging = false;
            let offsetX = 0;

            // Po naciÅ›niÄ™ciu na ÅºrÃ³dÅ‚o dÅºwiÄ™ku (np. samochÃ³d) zapamiÄ™taj przesuniÄ™cie kursora wzglÄ™dem Å›rodka obrazka
            movingDot.addEventListener("mousedown", (e) => {
                isDragging = true;
                const rect = movingDot.getBoundingClientRect();
                offsetX = e.clientX - (rect.left + rect.width / 2);
                document.body.style.cursor = "grabbing";
                e.preventDefault();
            });

            // Gdy przesuwamy mysz, a ÅºrÃ³dÅ‚o jest "zÅ‚apane", przesuÅ„ ÅºrÃ³dÅ‚o dÅºwiÄ™ku po osi X symulacji
            window.addEventListener("mousemove", (e) => {
                if (!isDragging) return;
                const containerRect = container.getBoundingClientRect();
                let x = e.clientX - containerRect.left - offsetX;
                x = Math.max(0, Math.min(x, containerRect.width)); // Ogranicz do szerokoÅ›ci kontenera
                const percent = (x / containerRect.width) * 100;
                movingDot.style.left = percent + "%";
                sourceX = percent; // Nowa pozycja ÅºrÃ³dÅ‚a dÅºwiÄ™ku
                clearReflectedWaves();       // CzyÅ›Ä‡ stare fale odbite
                updateMachConeAndLines();    // Aktualizuj wizualizacjÄ™ stoÅ¼ka Macha
                updateSpeedDisplay();        // Aktualizuj panel boczny
            });

            // Po puszczeniu myszy â€“Â przestaÅ„ przesuwaÄ‡ ÅºrÃ³dÅ‚o, przywrÃ³Ä‡ kursor
            window.addEventListener("mouseup", (e) => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "";
                }
            });

            // --- ObsÅ‚uga przeciÄ…gania obserwatora (postaÄ‡ czÅ‚owieka) ---
            let isDraggingObserver = false;
            let observerOffsetX = 0;

            // Analogicznie jak dla ÅºrÃ³dÅ‚a â€“ zÅ‚ap obserwatora (myszka na ikonie czÅ‚owieka)
            observer.addEventListener("mousedown", (e) => {
                isDraggingObserver = true;
                const rect = observer.getBoundingClientRect();
                observerOffsetX = e.clientX - (rect.left + rect.width / 2);
                document.body.style.cursor = "grabbing";
                clearReflectedWaves();
                e.preventDefault();
            });

            // PrzeciÄ…ganie obserwatora po osi X
            window.addEventListener("mousemove", (e) => {
                if (isDraggingObserver) {
                    const containerRect = container.getBoundingClientRect();
                    let x = e.clientX - containerRect.left - observerOffsetX;
                    x = Math.max(0, Math.min(x, containerRect.width));
                    const percent = (x / containerRect.width) * 100;
                    observer.style.left = percent + "%";
                    observerX = percent;   // Nowa pozycja obserwatora
                    clearReflectedWaves();
                    updateMachConeAndLines();
                    updateSpeedDisplay();
                }
            });

            // Po puszczeniu myszy przestaÅ„ przesuwaÄ‡ obserwatora, przywrÃ³Ä‡ kursor
            window.addEventListener("mouseup", (e) => {
                if (isDraggingObserver) {
                    isDraggingObserver = false;
                    document.body.style.cursor = "";
                }
            });

            // --- Ustawianie paneli bocznych jako przeciÄ…galne (drag&drop) przez caÅ‚y ich obszar ---
            makePanelDraggable(document.getElementById("speedDetails"), document.getElementById("speedDetails"));
            makePanelDraggable(document.getElementById("dopplerDetails"), document.getElementById("dopplerDetails"));

            // Panel sterowania moÅ¼na przesuwaÄ‡ za dedykowany uchwyt ("controls-handle")
            makePanelDraggable(document.getElementById("controls"), document.getElementById("controls-handle"));

            const tbody = document.getElementById("results-table-body");

            // --- ObsÅ‚uga przycisku "PokaÅ¼ wyniki" (modal z tabelÄ…) ---
            document.getElementById("show-results-btn").addEventListener("click", showResultsModal);

            // Zamknij modal po klikniÄ™ciu X
            document.getElementById("close-btn").addEventListener("click", () => {
                const modal = document.getElementById("results-modal");
                modal.style.display = "none";
            });

            // Zamknij modal po klikniÄ™ciu poza jego obszar (poza okienko)
            window.addEventListener("click", (e) => {
                const modal = document.getElementById("results-modal");
                if (e.target === modal) modal.style.display = "none";
            });
        });

        // Zabezpieczenie przed przypadkowym skalowaniem strony (zoom) podczas przewijania z wciÅ›niÄ™tym Ctrl
        window.addEventListener(
            "wheel",                // NasÅ‚uchuj kaÅ¼dego obrotu kÃ³Å‚kiem myszy
            function (e) {
                if (e.ctrlKey) {    // JeÅ¼eli uÅ¼ytkownik trzyma wciÅ›niÄ™ty klawisz Ctrl podczas scrollowania
                    e.preventDefault();  // Zablokuj domyÅ›lnÄ… akcjÄ™ (czyli powiÄ™kszanie/zmniejszanie strony)
                }
            },
            { passive: false }      // PozwÃ³l na wywoÅ‚anie e.preventDefault() (bez tego opcja jest ignorowana)
        );

    </script>
</body>

</html>