<!DOCTYPE html>
<html lang="pl">

<head>
    <!-- Bart≈Çomiej Barszczewski -->
    <!-- Symulacja zjawiska fizycznego -->
    <!-- Efekt Dopplera i zjawisko sto≈ºka macha -->
    <!-- Semestr drugi -->
    <!-- Fizyka -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Efekt Dopplera - Symulacja">
    <title>Efekt Dopplera - Symulacja</title>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div id="control-panel" class="control-panel">
        <button class="control-btn" id="startBtn">START</button>
        <button class="control-btn" id="pauseBtn">PAUZA</button>
        <button class="control-btn" id="resetBtn">RESET</button>
        <button class="control-btn" id="show-results-btn">POKA≈ª WYNIKI</button>
    </div>

    <div id="results-modal" style="display: none;" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-btn">&times;</span>
            <h2>Wyniki i wzory</h2>
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Parametr</th>
                        <th>Warto≈õƒá</th>
                        <th>Wz√≥r</th>
                    </tr>
                </thead>
                <tbody id="results-table-body"></tbody> <!-- üîß to musi byƒá -->
            </table>
        </div>
    </div>


    <div id="speedDetails" class="draggable-panel"></div>
    <div id="dopplerDetails" class="draggable-panel"></div>
    <!-- Suwaki kontrolne -->
    <div class="controls-container">
        <div class="controls" id="controls">
            <fieldset>
                <legend>Parametry ≈∫r√≥d≈Ça d≈∫wiƒôku</legend>

                <label for="speedControl">
                    Prƒôdko≈õƒá ≈∫r√≥d≈Ça V [m/s]:
                    <span id="speedDisplay">343</span>
                </label>
                <div class="slider-labels">
                    <span>Min 1</span>
                    <input type="range" id="speedControl" min="1" max="8000" step="1" value="20">
                    <span>Max 8000</span>
                </div>

                <label for="frequencyControl">
                    Czƒôstotliwo≈õƒá fali [Hz]:
                    <span id="frequencyDisplay"></span>
                </label>
                <div class="slider-labels">
                    <span>Min 20</span> <input type="range" id="frequencyControl" min="20" max="20000" step="1"
                        value="2500">
                    <span>Max 20_000</span>
                </div>
            </fieldset>
            <div class="drag-handle" id="controls-handle">:::</div>
            <div class="note">
                <p> Uwaga: <br>
                    Aktualna czƒôstotliwo≈õƒá jest dzielona przez 1000 w celu <br> zoptymalizowani ilo≈õci tworzenia siƒô
                    fal.<br />
                    PrzeglƒÖdarka posiada ograniczone mo≈ºliwo≈õci i przy ogromnej ilo≈õci element√≥w (fal), mo≈ºe zachowaƒá
                    siƒô w spos√≥b nieprzewidziany.
                </p>
            </div>
        </div>

    </div>

    <div class="container">
        <div class="line-x"></div>
        <img class="dot" id="movingDot" src="./css/img/car_yellow.png" alt="Moving source" />
        <img class="observer" id="observer1" style="left: 50%;" src="./css/img/human.png">
        <svg class="shockwaves" width="100%" height="100%">
            <line id="shockwave_upper" x1="0" y1="0" x2="0" y2="0" stroke="red" />
            <line id="shockwave_lower" x1="0" y1="0" x2="0" y2="0" stroke="red" />
        </svg>
        <!-- Skala osi X -->
        <div class="scale-x">
            <div class="scale-x-labels">
                <span style="left: 0;">-50</span>
                <span style="left: 10%;">-40</span>
                <span style="left: 20%;">-30</span>
                <span style="left: 30%;">-20</span>
                <span style="left: 40%;">-10</span>
                <span style="left: 50%;">0</span>
                <span style="left: 60%;">10</span>
                <span style="left: 70%;">20</span>
                <span style="left: 80%;">30</span>
                <span style="left: 90%;">40</span>
                <span style="left: 100%;">50</span>
            </div>
        </div>
    </div>

    <script defer>
        //================================================
        // Symulator efektu Dopplera - wyja≈õnienie funkcji

        /**
         * Oblicza czƒôstotliwo≈õƒá d≈∫wiƒôku odebranƒÖ przez obserwatora
         * przy efekcie Dopplera.
         * fz ‚Äì czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça [Hz]
         * v ‚Äì prƒôdko≈õƒá d≈∫wiƒôku [m/s]
         * vz ‚Äì prƒôdko≈õƒá ≈∫r√≥d≈Ça wzglƒôdem o≈õrodka (dodatnia je≈õli zbli≈ºa siƒô do obserwatora) [m/s]
         * vo ‚Äì prƒôdko≈õƒá obserwatora wzglƒôdem o≈õrodka (dodatnia je≈õli zbli≈ºa siƒô do ≈∫r√≥d≈Ça) [m/s]
         */
        const dopplerFrequencySound = (fz, v, vz, vo) => {
            // Je≈õli prƒôdko≈õƒá ≈∫r√≥d≈Ça >= prƒôdko≈õci fali, unikamy dzielenia przez zero lub ujemnej warto≈õci
            const denom = v - vz;
            if (Math.abs(vz) >= v) {
                // Korygujemy wz√≥r przy bardzo du≈ºych prƒôdko≈õciach ≈∫r√≥d≈Ça (nad≈∫wiƒôkowych)
                return fz * ((v + vo) / Math.abs(denom));
            }
            // Klasyczny wz√≥r Dopplera dla d≈∫wiƒôku w powietrzu
            return fz * ((v + vo) / denom);
        };

        /**
         * Oblicza d≈Çugo≈õƒá fali na podstawie czƒôstotliwo≈õci i prƒôdko≈õci fali.
         * fz ‚Äì czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça [Hz]
         * v ‚Äì prƒôdko≈õƒá d≈∫wiƒôku [m/s]
         */
        const countWaveLength = (fz, v) => {
            // Wz√≥r: lambda = v / f
            return v / fz;
        };

        /**
         * Oblicza prƒôdko≈õƒá ≈∫r√≥d≈Ça na podstawie czƒôstotliwo≈õci ≈∫r√≥d≈Ça i obserwowanej oraz prƒôdko≈õci d≈∫wiƒôku.
         * fz ‚Äì czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça [Hz]
         * fo ‚Äì czƒôstotliwo≈õƒá odebrana przez obserwatora [Hz]
         * v ‚Äì prƒôdko≈õƒá d≈∫wiƒôku [m/s]
         */
        const velocitySource = (fz, fo, v) => {
            // Wz√≥r przekszta≈Çcony z klasycznego efektu Dopplera dla ruchomego ≈∫r√≥d≈Ça
            return v * (1 - fz / fo);
        };

        /**
         * Oblicza prƒôdko≈õƒá obserwatora na podstawie czƒôstotliwo≈õci ≈∫r√≥d≈Ça i obserwowanej oraz prƒôdko≈õci d≈∫wiƒôku.
         * fz ‚Äì czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça [Hz]
         * fo ‚Äì czƒôstotliwo≈õƒá odebrana przez obserwatora [Hz]
         * v ‚Äì prƒôdko≈õƒá d≈∫wiƒôku [m/s]
         */
        const velocityObserver = (fz, fo, v) => {
            // Wz√≥r przekszta≈Çcony z efektu Dopplera dla ruchomego obserwatora
            return v * (fo / fz - 1);
        };

        // Odtwarza d≈∫wiƒôk (np. efekt sto≈ºka Macha) na podstawie wskazanego pliku audio
        function playSound(url) {
            const sound = new Audio(url); // Tworzy nowy obiekt Audio z podanym adresem pliku
            sound.play();                // Uruchamia odtwarzanie d≈∫wiƒôku (asynchronicznie)
        }

        // ======== POBRANIE ELEMENT√ìW DOM (HTML) DO OBS≈ÅUGI SYMULACJI ========

        // Obrazek symbolizujƒÖcy ≈∫r√≥d≈Ço d≈∫wiƒôku (ruchomy punkt ‚Äì samoch√≥d/odrzutowiec itp.)
        const movingDot = document.getElementById("movingDot");

        // G≈Ç√≥wna kontener dla ca≈Çej symulacji (obszar animacji)
        const container = document.querySelector(".container");

        // Suwak do ustawiania prƒôdko≈õci ≈∫r√≥d≈Ça d≈∫wiƒôku
        const speedControl = document.getElementById("speedControl");

        // Suwak do ustawiania czƒôstotliwo≈õci d≈∫wiƒôku
        const frequencyControl = document.getElementById("frequencyControl");

        // Wy≈õwietlanie aktualnej prƒôdko≈õci (warto≈õƒá numeryczna przy suwaku)
        const speedDisplay = document.getElementById("speedDisplay");

        // Wy≈õwietlanie aktualnej czƒôstotliwo≈õci (warto≈õƒá numeryczna przy suwaku)
        const frequencyDisplay = document.getElementById("frequencyDisplay");

        // Panel boczny wy≈õwietlajƒÖcy szczeg√≥≈Çy prƒôdko≈õci, liczby Macha itd.
        const speedDetails = document.getElementById("speedDetails");

        // Linie wizualizujƒÖce sto≈ºek Macha (g√≥rna i dolna krawƒôd≈∫)
        const shockwaveUpper = document.getElementById("shockwave_upper");
        const shockwaveLower = document.getElementById("shockwave_lower");

        // Obrazek obserwatora (postaƒá cz≈Çowieka na osi symulacji)
        const observer = document.getElementById("observer1");

        // ======== STA≈ÅE USTAWIENIA FIZYCZNE I SYMULACYJNE ========

        // Domy≈õlna czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça d≈∫wiƒôku (Hz)
        const DEFAULT_FREQ = 400;

        // Domy≈õlna prƒôdko≈õƒá ≈∫r√≥d≈Ça (m/s)
        const DEFAULT_SPEED = 25;

        // Prƒôdko≈õƒá d≈∫wiƒôku w powietrzu (m/s)
        const SPEED_OF_SOUND = 343;

        // Przelicznik: ile metr√≥w przypada na 1% szeroko≈õci ekranu (do przeliczania pozycji)
        const METERS_PER_PERCENT = 3.43;

        // Symulowana prƒôdko≈õƒá d≈∫wiƒôku (na skalƒô procentowƒÖ symulacji)
        const SPEED_OF_SOUND_SIM = SPEED_OF_SOUND / METERS_PER_PERCENT;

        // Wsp√≥≈Çczynnik skalowania ruchu ≈∫r√≥d≈Ça w animacji
        const SCALE_FACTOR = 1.5;

        // Czas ≈ºycia pojedynczej fali (ile sekund jest animowana)
        const WAVE_LIFETIME = 2;

        // Szeroko≈õƒá sto≈ºka Macha w procentach (do wizualizacji)
        const CONE_WIDTH_PERCENT = 30;

        // Minimalny odstƒôp czasowy miƒôdzy kolejnymi sto≈ºkami Macha (sekundy)
        const MIN_SHOCKWAVE_INTERVAL = 5;

        // Skala czƒôstotliwo≈õci (zmniejszamy czƒôstotliwo≈õƒá do optymalizacji rysowania fal)
        const FREQUENCY_SCALE_FACTOR = 1000;

        // ======== ZMIENNE GLOBALNE - AKTUALNY STAN SYMULACJI ========

        // Pozycja obserwatora na osi X (procent kontenera, 0‚Äì100)
        let observerX = 50;

        // Pozycja ≈∫r√≥d≈Ça d≈∫wiƒôku na osi X (procent kontenera, 0‚Äì100)
        let sourceX = 50;

        // Prƒôdko≈õƒá ≈∫r√≥d≈Ça (pobierana z suwaka lub domy≈õlna)
        let speed = parseFloat(speedControl.value) || DEFAULT_SPEED;

        // Czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça (pobierana z suwaka lub domy≈õlna), dzielona na 100 (optymalizacja)
        let sourceFrequency = parseFloat(frequencyControl.value / 100) || DEFAULT_FREQ;

        // Ostatni moment wygenerowania fali (sekundy, do kontroli interwa≈Çu emisji fal)
        let lastWaveTime = 0;

        // Tablica przechowujƒÖca aktualnie animowane fale
        let waves = [];

        // Czy czƒôstotliwo≈õƒá zosta≈Ça ustawiona rƒôcznie przez u≈ºytkownika (true/false)
        let isFrequencyManual = false;

        // Aktualny typ pojazdu/obiektu (car/ambulance/sport/jet/missile)
        let currentType = null;

        // Pozycja ≈∫r√≥d≈Ça przy ostatnim wyemitowanym sto≈ºku Macha (do ograniczenia czƒôsto≈õci)
        let lastShockwavePos = null;

        // Czas ostatniego wyemitowania sto≈ºka Macha (sekundy)
        let lastShockwaveTime = 0;

        // Ostatnio obliczona czƒôstotliwo≈õƒá obserwowana (Doppler)
        let freqObserver = null;

        // Timeouty do obs≈Çugi fal odbitych (clearTimeout itd.)
        let reflectedWaveTimeouts = [];

        // Timeouty do fal odbitych w 2D
        let reflection2DTimeouts = [];

        // ======== AUDIO (generowanie d≈∫wiƒôku w czasie rzeczywistym) ========

        // Sta≈Ça z prƒôdko≈õciƒÖ d≈∫wiƒôku (skr√≥cona notacja)
        const c = SPEED_OF_SOUND;

        // Kontekst Web Audio API
        let audioContext = null;

        // Oscylator d≈∫wiƒôku (generator tonu)
        let osc = null;

        // Kontrola g≈Ço≈õno≈õci d≈∫wiƒôku
        let gain = null;

        // Oscylator LFO (np. do modulacji syreny ambulansu)
        let lfo = null;

        // Kontrola g≈Çƒôboko≈õci modulacji LFO
        let lfoGain = null;

        // Typ aktualnie odtwarzanego d≈∫wiƒôku (np. "car", "ambulance", itd.)
        let currentSoundType = null;

        // Typ d≈∫wiƒôku przy poprzednim wywo≈Çaniu (do detekcji zmiany)
        let lastEngineSoundType = null;

        // Czy symulacja jest zapauzowana
        let isPaused = false;

        function showResultsModal() {
            // Okno z tabelƒÖ wynik√≥w
            const modalResults = document.getElementById("results-modal");

            // Je≈õli symulacja nie jest zapauzowana ‚Äì zamiast wynik√≥w, miga przycisk pauzy (u≈ºytkownik musi najpierw zatrzymaƒá)
            if (!isPaused) {
                const pauseBtn = document.getElementById("pauseBtn");

                // Funkcja pomocnicza do migania kolorem przycisku "PAUZA"
                const flashColor = (bg, color, delay) => {
                    setTimeout(() => {
                        pauseBtn.style.backgroundColor = bg;
                        pauseBtn.style.color = color;
                    }, delay);
                };

                // Kilkukrotne miganie czerwonym kolorem na przycisku pauzy
                flashColor("red", "white", 0);
                flashColor("#fff", "black", 300);
                flashColor("red", "white", 600);
                flashColor("#fff", "black", 900);
                flashColor("red", "white", 1500);
                flashColor("#fff", "black", 1800);
                flashColor("red", "white", 2100);
                flashColor("#fff", "black", 2400);
                return; // Ko≈Ñczymy bez wy≈õwietlania modala, dop√≥ki nie zapauzujemy
            }

            // ===== OBLICZENIA FIZYCZNE DO WY≈öWIETLENIA WYNIK√ìW =====

            // Prƒôdko≈õƒá w km/h i mph
            const kmh = speed * 3.6;
            const mph = speed * 2.23694;

            // Liczba Macha
            const mach = speed / SPEED_OF_SOUND;

            // D≈Çugo≈õƒá fali (lambda)
            const lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);

            // Prƒôdko≈õƒá wzglƒôdna ≈∫r√≥d≈Ça do obserwatora (wa≈ºne dla efektu Dopplera)
            const relativeVelocity = sourceX < observerX ? speed : -speed;

            // Czƒôstotliwo≈õƒá obserwowana przez obserwatora (efekt Dopplera)
            const freqObserverNum = dopplerFrequencySound(
                sourceFrequency, SPEED_OF_SOUND, relativeVelocity, 0
            );

            // Przesuniƒôcie czƒôstotliwo≈õci (Doppler shift)
            const deltaF = freqObserverNum - sourceFrequency;

            // Wsp√≥≈Çczynnik Dopplera (proporcja zmiany czƒôstotliwo≈õci)
            const dopplerCoeff = freqObserverNum / sourceFrequency;

            // Odleg≈Ço≈õƒá procentowa miƒôdzy ≈∫r√≥d≈Çem a obserwatorem (w jednostce symulacji)
            const distancePercent = Math.abs(observerX - sourceX);

            // Odleg≈Ço≈õƒá rzeczywista w metrach (do oblicze≈Ñ fizycznych)
            const distanceMeters = distancePercent * METERS_PER_PERCENT;

            // Czas dotarcia fali do obserwatora (sekundy)
            const timeToObserver = distanceMeters / SPEED_OF_SOUND;

            // Przesuniƒôcie fazowe fali (w radianach)
            const phaseShift = (2 * Math.PI * distanceMeters) / (lambda > 0 ? lambda : 1);

            // Energia fali przy obserwatorze (proporcjonalnie do 1/d^2)
            const energyAtObs = 1 / Math.pow(distanceMeters || 1, 2);

            // Czy d≈∫wiƒôk jest s≈Çyszalny dla cz≈Çowieka (zakres 20-20000 Hz)
            const isAudible = sourceFrequency >= 20 && sourceFrequency <= 20000;

            // Opis po≈Ço≈ºenia ≈∫r√≥d≈Ça wzglƒôdem obserwatora
            const distanceText =
                sourceX - observerX < 0
                    ? `PRZED obserwatorem (-${distancePercent.toFixed(2)}%)`
                    : sourceX - observerX > 0
                        ? `ZA obserwatorem (+${distancePercent.toFixed(2)}%)`
                        : "Na obserwatorze (0%)";

            // Tablica wierszy do tabeli wynik√≥w ‚Äì [Parametr, Warto≈õƒá, Wz√≥r]
            const rows = [
                ["Prƒôdko≈õƒá", `${speed.toFixed(2)} m/s | ${kmh.toFixed(2)} km/h | ${mph.toFixed(2)} mph`, "‚Äî"],
                ["Liczba Macha", mach.toFixed(2), "M = v / v_d≈∫w"],
                ["Czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça", `${sourceFrequency.toFixed(1)} Hz`, "Dana"],
                ["D≈Çugo≈õƒá fali", `${lambda.toFixed(2)} m`, "Œª = v_d≈∫w / f‚ÇÄ"],
                ["Czƒôstotliwo≈õƒá obserwatora", `${freqObserverNum.toFixed(1)} Hz`, "f' = f‚ÇÄ ¬∑ v_d≈∫w / (v_d≈∫w - v)"],
                ["KƒÖt sto≈ºka Macha", mach < 1 ? "‚Äî" : `asin(1/M)`, "sin(Œ∏) = v_d≈∫w / v (dla M > 1)"],
                ["Odleg≈Ço≈õƒá od obserwatora", distanceText, "Œîx = x‚ÇÄ - x_obs"],
                ["Œîf (Przesuniƒôcie Dopplera)", `${deltaF.toFixed(2)} Hz`, "Œîf = f' - f‚ÇÄ"],
                ["Wsp√≥≈Çczynnik Dopplera", dopplerCoeff.toFixed(3), "f' / f‚ÇÄ"],
                ["Czas dotarcia fali", `${timeToObserver.toFixed(3)} s`, "t = d / v_d≈∫w"],
                ["Przesuniƒôcie fazowe", `${phaseShift.toFixed(2)} rad`, "ŒîœÜ = 2œÄ ¬∑ d / Œª"],
                ["Energia wzglƒôdna", energyAtObs.toExponential(2), "E ‚àù 1 / d¬≤"],
                ["S≈Çyszalno≈õƒá", isAudible ? "TAK" : "NIE", "f‚ÇÄ ‚àà [20, 20000] Hz"],
            ];

            // Pobierz element tbody z tabeli wynik√≥w (czy≈õƒá poprzednie wiersze)
            const tbody = document.getElementById("results-table-body");
            tbody.innerHTML = "";

            // Dodaj wszystkie wiersze do tabeli wynik√≥w
            rows.forEach(([param, value, formula]) => {
                const row = document.createElement("tr");
                row.innerHTML = `<td>${param}</td><td>${value}</td><td>${formula}</td>`;
                tbody.appendChild(row);
            });

            modalResults.style.display = "flex";
        }

        // Funkcja uruchamiajƒÖca d≈∫wiƒôk syreny ambulansu
        function startAmbulanceSiren() {
            // Najpierw zatrzymujemy (i czy≈õcimy) poprzedniƒÖ syrenƒô je≈õli dzia≈Ça≈Ça
            stopAmbulanceSiren();

            // Tworzymy nowy kontekst audio (Web Audio API)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Tworzymy oscylator bazowy ‚Äì generuje g≈Ç√≥wny ton syreny
            osc = audioContext.createOscillator();
            osc.type = "square";        // Typ fali: prostokƒÖtna (wyrazisty d≈∫wiƒôk syreny)
            osc.frequency.value = 700;  // Czƒôstotliwo≈õƒá podstawowa: 700 Hz

            // Tworzymy oscylator LFO (Low Frequency Oscillator) ‚Äì do modulacji czƒôstotliwo≈õci (efekt "wycia" syreny)
            lfo = audioContext.createOscillator();
            lfo.type = "triangle";      // Typ fali: tr√≥jkƒÖtna (≈Çagodne przej≈õcia)
            lfo.frequency.value = 5;    // Czƒôstotliwo≈õƒá LFO: 5 Hz (czyli 5 razy na sekundƒô zmienia siƒô ton)

            // Tworzymy kontrolƒô g≈Çƒôboko≈õci modulacji LFO (jak bardzo LFO wp≈Çywa na ton g≈Ç√≥wny)
            lfoGain = audioContext.createGain();
            lfoGain.gain.value = 250;   // G≈Çƒôboko≈õƒá modulacji (w Hz)

            // ≈ÅƒÖczymy LFO z kontrolƒÖ g≈Çƒôboko≈õci
            lfo.connect(lfoGain);

            // LFO steruje czƒôstotliwo≈õciƒÖ oscylatora g≈Ç√≥wnego (osc)
            lfoGain.connect(osc.frequency);

            // Tworzymy kontrolƒô g≈Ço≈õno≈õci
            gain = audioContext.createGain();
            gain.gain.value = 0.5;     // Bardzo cicho, ≈ºeby nie og≈Çuszyƒá u≈ºytkownika

            // Pod≈ÇƒÖczamy oscylator do kontroli g≈Ço≈õno≈õci
            osc.connect(gain);

            // Pod≈ÇƒÖczamy do wyj≈õcia audio (g≈Ço≈õniki)
            gain.connect(audioContext.destination);

            // Startujemy oba oscylatory (ton g≈Ç√≥wny i LFO)
            osc.start();
            lfo.start();
        }

        // Funkcja zatrzymujƒÖca d≈∫wiƒôk syreny ambulansu i czy≈õci wszystko
        function stopAmbulanceSiren() {
            // Zatrzymanie i roz≈ÇƒÖczenie oscylatora g≈Ç√≥wnego
            if (osc) {
                try {
                    osc.stop();
                    osc.disconnect();
                } catch (e) { }
                osc = null;
            }
            // Zatrzymanie i roz≈ÇƒÖczenie LFO
            if (lfo) {
                try {
                    lfo.stop();
                    lfo.disconnect();
                } catch (e) { }
                lfo = null;
            }
            // Roz≈ÇƒÖczenie kontroli g≈Çƒôboko≈õci LFO
            if (lfoGain) {
                try {
                    lfoGain.disconnect();
                } catch (e) { }
                lfoGain = null;
            }
            // Roz≈ÇƒÖczenie kontroli g≈Ço≈õno≈õci
            if (gain) {
                try {
                    gain.disconnect();
                } catch (e) { }
                gain = null;
            }
            // Zamykanie kontekstu audio (zwalniamy zasoby)
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (e) { }
                audioContext = null;
            }
        }

        // Funkcja uruchamiajƒÖca d≈∫wiƒôk silnika wybranego typu pojazdu (car, sport, ambulance, jet, missile itd.)
        function startEngineSound(type) {
            // Je≈õli d≈∫wiƒôk ju≈º gra dla tego typu, nie r√≥b nic (unika prze≈Çadowa≈Ñ d≈∫wiƒôku przy niezmienionym typie)
            if (currentSoundType === type) return;

            // Zatrzymaj i wyczy≈õƒá poprzedni d≈∫wiƒôk silnika (je≈õli jaki≈õ gra≈Ç)
            stopEngineSound();

            // Ustaw aktualny typ d≈∫wiƒôku silnika
            currentSoundType = type;

            // Je≈õli typ to "ambulance", uruchom d≈∫wiƒôk syreny (specjalna logika)
            if (type === "ambulance") {
                startAmbulanceSiren();
                return; // Nie tworzymy w≈Çasnego oscylatora, bo syrena ma w≈Çasny
            }

            // Tworzenie nowego kontekstu audio (Web Audio API)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Tworzenie oscylatora (generatora d≈∫wiƒôku)
            osc = audioContext.createOscillator();

            // Tworzenie kontroli g≈Ço≈õno≈õci
            gain = audioContext.createGain();

            // Ustawianie typu fali i czƒôstotliwo≈õci w zale≈ºno≈õci od pojazdu
            if (type === "car") {
                osc.type = "square";          // Fala prostokƒÖtna ‚Äì typowy, wyra≈∫ny d≈∫wiƒôk silnika spalinowego
                osc.frequency.value = 120;    // Czƒôstotliwo≈õƒá podstawowa: 120 Hz
            } else if (type === "sport") {
                osc.type = "square";          // Fala prostokƒÖtna ‚Äì sportowy, ni≈ºszy d≈∫wiƒôk
                osc.frequency.value = 60;     // Czƒôstotliwo≈õƒá podstawowa: 60 Hz
            } else {
                osc.type = "sine";            // Inny typ ‚Äì fala sinusoidalna (np. rakieta, odrzutowiec)
                osc.frequency.value = 40;     // Bardzo niski d≈∫wiƒôk
            }

            // Ustawienie g≈Ço≈õno≈õci wyj≈õciowej (0.5 ‚Äì po≈Çowa skali)
            gain.gain.value = 0.5;

            // Pod≈ÇƒÖczenie oscylatora do gain (g≈Ço≈õno≈õƒá)
            osc.connect(gain);

            // Pod≈ÇƒÖczenie gain do wyj≈õcia audio (g≈Ço≈õniki)
            gain.connect(audioContext.destination);

            // Rozpoczƒôcie odtwarzania d≈∫wiƒôku
            osc.start();
        }

        // Funkcja zatrzymujƒÖca d≈∫wiƒôk silnika (dowolnego typu)
        function stopEngineSound() {
            // Najpierw zatrzymaj i wyczy≈õƒá syrenƒô ambulansu (je≈õli by≈Ça aktywna)
            stopAmbulanceSiren();

            // Zatrzymanie i roz≈ÇƒÖczenie oscylatora (je≈õli by≈Ç uruchomiony)
            if (osc) {
                try {
                    osc.stop();
                    osc.disconnect();
                } catch (e) { }
                osc = null;
            }

            // Roz≈ÇƒÖczenie kontroli g≈Ço≈õno≈õci
            if (gain) {
                try {
                    gain.disconnect();
                } catch (e) { }
                gain = null;
            }

            // Zamkniƒôcie kontekstu audio
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (e) { }
                audioContext = null;
            }

            // Reset typu d≈∫wiƒôku
            currentSoundType = null;
        }

        function updateEngineSound(type, srcX, observerX, v) {
            // Zmiana typu d≈∫wiƒôku = prze≈ÇƒÖcz silnik/syrenƒô
            if (type !== lastEngineSoundType) {
                startEngineSound(type); // wywo≈Ça poprawnƒÖ funkcjƒô dla typu (w tym startAmbulanceSiren)
                lastEngineSoundType = type;
            }

            // Nieobs≈Çugiwane typy = wy≈ÇƒÖcz audio
            if (!["car", "ambulance", "sport"].includes(type)) {
                stopEngineSound();
                return;
            }

            // ---- Dla ambulansu: tylko g≈Ço≈õno≈õƒá (osc, freq ustawia syrena sama) ----
            if (type === "ambulance" && gain && audioContext) {
                const percentToMeters = METERS_PER_PERCENT;
                const distance = Math.abs(srcX - observerX) * percentToMeters;
                const minDistance = 1;
                const volume = Math.min(1, 1 / Math.pow(Math.max(distance, minDistance), 2)) * 0.07; // podbij na test!
                const silenceThreshold = 40;
                const appliedVolume = distance > silenceThreshold ? 0 : volume;
                gain.gain.linearRampToValueAtTime(appliedVolume, audioContext.currentTime + 0.03);
            }

            // ---- Dla car/sport: g≈Ço≈õno≈õƒá + czƒôstotliwo≈õƒá (Doppler) ----
            if ((type === "car" || type === "sport") && gain && osc && audioContext) {
                const percentToMeters = METERS_PER_PERCENT;
                const distance = Math.abs(srcX - observerX) * percentToMeters;
                const minDistance = 1;
                const volume = Math.min(1, 1 / Math.pow(Math.max(distance, minDistance), 2)) * 0.3;
                const silenceThreshold = 20;
                const appliedVolume = distance > silenceThreshold ? 0 : volume;

                let base, scale, low, high;
                if (type === "car") {
                    base = 80;
                    scale = 0.6;
                    low = 50;
                    high = 220;
                } else { // "sport"
                    base = 30;
                    scale = 0.11;
                    low = 20;
                    high = 52;
                }
                let freq = base + scale * v;
                freq = Math.max(low, Math.min(freq, high));
                const relativeVelocity = srcX < observerX ? v : -v;
                const dopplerFreq = dopplerFrequencySound(freq, SPEED_OF_SOUND, relativeVelocity, 0);
                gain.gain.linearRampToValueAtTime(appliedVolume, audioContext.currentTime + 0.02);
                osc.frequency.linearRampToValueAtTime(dopplerFreq, audioContext.currentTime + 0.02);
            }
        }


        // Aktualizuje wy≈õwietlane warto≈õci prƒôdko≈õci i czƒôstotliwo≈õci w panelu sterowania
        function updateDisplays() {
            // Wy≈õwietl aktualnƒÖ warto≈õƒá prƒôdko≈õci z suwaka
            speedDisplay.textContent = speedControl.value;
            // Wy≈õwietl aktualnƒÖ warto≈õƒá czƒôstotliwo≈õci z suwaka
            frequencyDisplay.textContent = frequencyControl.value;
        }

        // Aktualizuje wizualizacjƒô sto≈ºka Macha i linii uderzeniowych dla prƒôdko≈õci nadd≈∫wiƒôkowych
        function updateMachConeAndLines() {
            // Pobiera pozycjƒô (prostokƒÖt) poruszajƒÖcego siƒô ≈∫r√≥d≈Ça d≈∫wiƒôku wzglƒôdem okna
            const rect = movingDot.getBoundingClientRect();
            // Pobiera pozycjƒô kontenera, w kt√≥rym znajduje siƒô ≈∫r√≥d≈Ço
            const containerRect = container.getBoundingClientRect();
            // Korekta przesuniƒôcia (offset), by poprawnie wycentrowaƒá sto≈ºek wzglƒôdem grafiki
            const adjust = -25;
            // Oblicza wsp√≥≈ÇrzƒôdnƒÖ X (≈õrodek ≈∫r√≥d≈Ça wzglƒôdem kontenera)
            const dotX = rect.left - adjust - containerRect.left + rect.width / 2;
            // Oblicza wsp√≥≈ÇrzƒôdnƒÖ Y (≈õrodek ≈∫r√≥d≈Ça wzglƒôdem kontenera)
            const dotY = rect.top - containerRect.top + rect.height / 2;

            // Aktualna prƒôdko≈õƒá ≈∫r√≥d≈Ça, pobrana z suwaka
            const V = parseFloat(speedControl.value);

            // Je≈õli prƒôdko≈õƒá przekracza lub r√≥wna prƒôdko≈õci d≈∫wiƒôku ‚Äì wy≈õwietlamy sto≈ºek Macha
            if (V >= SPEED_OF_SOUND) {
                // Liczba Macha: ile razy prƒôdko≈õƒá ≈∫r√≥d≈Ça przekracza prƒôdko≈õƒá d≈∫wiƒôku
                const M = V / SPEED_OF_SOUND;
                // Obliczamy kƒÖt sto≈ºka Macha (asin(1/M))
                const theta = Math.asin(1 / M);
                // Tangens tego kƒÖta, potrzebny do wyznaczenia ko≈Ñcowych punkt√≥w linii
                const tanTheta = Math.tan(theta);
                // Y-owa wsp√≥≈Çrzƒôdna ko≈Ñca g√≥rnej linii sto≈ºka
                const y2_upper = dotY + tanTheta * dotX;
                // Y-owa wsp√≥≈Çrzƒôdna ko≈Ñca dolnej linii sto≈ºka
                const y2_lower = dotY - tanTheta * dotX;

                // Ustawia poczƒÖtek i koniec g√≥rnej linii sto≈ºka (SVG <line>)
                shockwaveUpper.setAttribute("x1", dotX);
                shockwaveUpper.setAttribute("y1", dotY);
                shockwaveUpper.setAttribute("x2", 0);
                shockwaveUpper.setAttribute("y2", y2_upper);

                // Ustawia poczƒÖtek i koniec dolnej linii sto≈ºka (SVG <line>)
                shockwaveLower.setAttribute("x1", dotX);
                shockwaveLower.setAttribute("y1", dotY);
                shockwaveLower.setAttribute("x2", 0);
                shockwaveLower.setAttribute("y2", y2_lower);

                // Pokazuje obie linie sto≈ºka
                shockwaveUpper.style.display = "block";
                shockwaveLower.style.display = "block";
            } else {
                // Dla prƒôdko≈õci podd≈∫wiƒôkowych ukryj sto≈ºek Macha
                shockwaveUpper.style.display = "none";
                shockwaveLower.style.display = "none";
            }
        }

        // Funkcja tworzy i animuje falƒô odbitƒÖ (np. odbicie od obserwatora) w widoku 2D
        function createReflectionWave(xPosition, yPosition, amplitude = 1) {
            // 1. Tworzymy nowy element <div> ‚Äì to bƒôdzie graficzna reprezentacja fali
            const wave = document.createElement("div");
            // 2. Nadajemy mu klasƒô CSS, kt√≥ra ustawia odpowiedni wyglƒÖd (kolor, border, animacje)
            wave.classList.add("wave-reflected-2d");

            // 3. Specjalna obs≈Çuga dla typu "jet" i "missile" (odrzutowiec lub pocisk nadd≈∫wiƒôkowy):
            //    Fala odbita pojawia siƒô dok≈Çadnie w miejscu obserwatora ‚Äì u≈ºywamy wsp√≥≈Çrzƒôdnych pikselowych, a nie procentowych!
            if (currentType === "jet" || currentType === "missile") {
                // a) Pobieramy aktualny prostokƒÖt (pozycja, rozmiar) obserwatora wzglƒôdem okna przeglƒÖdarki
                const observerRect = observer.getBoundingClientRect();
                // b) Pobieramy pozycjƒô kontenera animacji (≈ºeby ustaliƒá po≈Ço≈ºenie wzglƒôdne)
                const containerRect = container.getBoundingClientRect();
                // c) Wyliczamy po≈Ço≈ºenie X ≈õrodka obserwatora wzglƒôdem kontenera (lewy brzeg + po≈Çowa szeroko≈õci)
                const leftPx = observerRect.left - containerRect.left + observerRect.width / 2;
                // d) Wyliczamy po≈Ço≈ºenie Y ≈õrodka obserwatora wzglƒôdem kontenera (g√≥rny brzeg + po≈Çowa wysoko≈õci)
                const topPx = observerRect.top - containerRect.top + observerRect.height / 2;
                // e) Ustawiamy falƒô dok≈Çadnie na ≈õrodku obserwatora
                wave.style.left = `${leftPx}px`;
                wave.style.top = `${topPx}px`;
                // f) Upewniamy siƒô, ≈ºe pozycja jest absolutna (nie np. procentowa czy relatywna)
                wave.style.position = "absolute";
            } else {
                // 4. W zwyk≈Çych przypadkach (np. samoch√≥d, ambulans) ‚Äì ustawiamy pozycjƒô na podstawie warto≈õci procentowych (proporcje wzglƒôdem szeroko≈õci/wysoko≈õci kontenera)
                wave.style.left = `${xPosition}%`;
                wave.style.top = `${yPosition}%`;
            }

            // 5. Ustawiamy przezroczysto≈õƒá fali (amplituda), np. 1 = pe≈Çna widoczno≈õƒá, 0.5 = p√≥≈Çprzezroczysta
            wave.style.opacity = amplitude;
            // 6. Rozmiar poczƒÖtkowy fali (startuje jako ma≈Çe ko≈Ço)
            wave.style.width = "20px";
            wave.style.height = "20px";
            // 7. Transformacja CSS: centrowanie fali wzglƒôdem jej ≈õrodka + bardzo ma≈Ça poczƒÖtkowa skala
            wave.style.transform = "translate(-50%, -50%) scale(0.2)";
            // 8. Dodajemy falƒô do g≈Ç√≥wnego kontenera animacji na scenie
            container.appendChild(wave);

            // 9. Uruchamiamy animacjƒô CSS (API Web Animations): powiƒôkszanie i znikanie fali
            wave.animate(
                [
                    // a) Stan poczƒÖtkowy: ma≈Ça skala (0.2), pe≈Çna amplituda (widoczno≈õƒá)
                    { transform: "translate(-50%, -50%) scale(0.2)", opacity: amplitude },
                    // b) Stan ko≈Ñcowy: bardzo du≈ºa skala (10x), przezroczysto≈õƒá 0 (zanika)
                    { transform: "translate(-50%, -50%) scale(10)", opacity: 0 },
                ],
                {
                    // c) Ca≈Ça animacja trwa 1000 ms (1 sekunda)
                    duration: 1000,
                    // d) Animacja jest liniowa ‚Äì tempo nie przyspiesza ani nie zwalnia
                    easing: "linear"
                }
            );

            // 10. Po zako≈Ñczeniu animacji (po 1 sekundzie) ‚Äì usuwamy falƒô z DOM, ≈ºeby nie za≈õmiecaƒá pamiƒôci i nie obciƒÖ≈ºaƒá przeglƒÖdarki
            setTimeout(() => wave.remove(), 1000);
        }

        // Planuje (z op√≥≈∫nieniem) pojawienie siƒô fali odbitej od obserwatora w 2D
        function schedule2DReflection(observerPosPercent, wavePosPercent, timestamp) {
            // Obliczamy odleg≈Ço≈õƒá (w metrach) pomiƒôdzy miejscem fali a obserwatorem
            const distanceMeters = Math.abs(observerPosPercent - wavePosPercent) * METERS_PER_PERCENT;
            // Obliczamy ile sekund zajmie fali przebycie tej odleg≈Ço≈õci z aktualnƒÖ prƒôdko≈õciƒÖ d≈∫wiƒôku
            const delaySeconds = distanceMeters / SPEED_OF_SOUND;
            // Ustawiamy timeout ‚Äì po up≈Çywie wyliczonego czasu tworzymy animacjƒô odbitej fali
            const timeoutId = setTimeout(() => {
                // Fala odbita zawsze pojawia siƒô dok≈Çadnie na pozycji obserwatora (Y=50% ‚Äì ≈õrodek ekranu)
                createReflectionWave(observerPosPercent, 50, 1);
            }, delaySeconds * 1000);

            // Zapamiƒôtujemy identyfikator timeoutu, by p√≥≈∫niej m√≥c go anulowaƒá je≈õli zajdzie taka potrzeba
            reflection2DTimeouts.push(timeoutId);
        }

        // Tworzy i animuje nowƒÖ falƒô wychodzƒÖcƒÖ od ≈∫r√≥d≈Ça d≈∫wiƒôku
        function createWave(xPosition, timestamp) {
            // Gdy liczba fal na ekranie przekracza 1000 ‚Äì usuwamy najstarszƒÖ, ≈ºeby nie przepe≈Çniƒá pamiƒôci/przeglƒÖdarki
            if (waves.length > 1000) {
                const oldest = waves.shift();
                if (oldest && oldest.element) oldest.element.remove();
            }

            // Tworzymy nowy element reprezentujƒÖcy falƒô
            const wave = document.createElement("div");
            wave.classList.add("wave"); // Nadajemy mu odpowiedniƒÖ klasƒô CSS

            // Ustawiamy pozycjƒô X (procent szeroko≈õci kontenera)
            wave.style.left = `${xPosition}%`;
            // Pozycja Y lekko poni≈ºej ≈õrodka (lepiej wyglƒÖda wizualnie)
            wave.style.top = "49%";
            // Obliczamy przesuniƒôcie X (symulacja ruchu fal za poruszajƒÖcym siƒô ≈∫r√≥d≈Çem)
            const translateX = -(50 + (50 * speed) / SPEED_OF_SOUND);
            wave.style.transform = `translate(${translateX}%, -50%)`;

            // Dodajemy falƒô do kontenera animacji
            container.appendChild(wave);

            // Obliczamy d≈Çugo≈õƒá fali (lambda)
            let lambda;
            try {
                lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);
            } catch (error) {
                console.error("B≈ÇƒÖd w countWaveLength:", error);
                lambda = 1; // awaryjnie ustawiamy d≈Çugo≈õƒá fali na 1, by uniknƒÖƒá dalszych b≈Çƒôd√≥w
            }

            // Animacja CSS: "rozszerzanie" fali przez zadany czas trwania
            wave.style.animation = `wave-expand ${WAVE_LIFETIME}s linear forwards`;

            // Skala ko≈Ñcowa animacji zale≈ºy od typu pojazdu (inne dla np. jet, car, sport)
            let finalScale;
            switch (currentType) {
                case "car":
                    finalScale = 30;
                    break;
                case "ambulance":
                    finalScale = 30;
                    break;
                case "sport":
                    finalScale = 30;
                    break;
                case "jet":
                case "missile":
                    if(speed < SPEED_OF_SOUND) {
                        finalScale = 50;
                    }
                    if(speed >= SPEED_OF_SOUND) {
                        finalScale = 90;
                    }
                    break;
                default:
                    finalScale = 30;
            }

            // Dodatkowa animacja (JS) dla p≈Çynnego przej≈õcia skali i przezroczysto≈õci
            wave.animate(
                [
                    { transform: "scale(0.6)", opacity: 1 },             // poczƒÖtek: ma≈Ça, widoczna fala
                    { transform: `scale(${finalScale})`, opacity: 0 },   // koniec: du≈ºa, przezroczysta fala
                ],
                {
                    duration: WAVE_LIFETIME * 1000,    // czas trwania (ms)
                    easing: "linear",                  // tempo liniowe
                    fill: "forwards",                  // po zako≈Ñczeniu animacji zostaje w stanie ko≈Ñcowym
                }
            );

            // Dodajemy nowƒÖ falƒô do listy aktualnych fal (z metadanymi)
            waves.push({
                element: wave,
                xPosition: xPosition,
                createdAt: timestamp / 1000, // czas utworzenia (w sekundach)
            });

            // Po wyga≈õniƒôciu animacji usuwamy falƒô z DOM oraz z listy fal (by nie za≈õmiecaƒá)
            setTimeout(() => {
                wave.remove();
                waves = waves.filter((w) => w.element !== wave);
            }, WAVE_LIFETIME * 1000);

            // Je≈õli ≈∫r√≥d≈Ço porusza siƒô wolniej ni≈º d≈∫wiƒôk (tylko podd≈∫wiƒôkowe), rozpatrujemy odbicia fali
            if (speed < SPEED_OF_SOUND) {
                // Obliczamy dystans fali do obserwatora w metrach
                const distanceMeters = Math.abs(observerX - xPosition) * METERS_PER_PERCENT;
                // Czas dotarcia tej fali do obserwatora
                const timeToObserver = distanceMeters / SPEED_OF_SOUND;

                // Je≈ºeli fala dotrze do obserwatora w ciƒÖgu 15% czasu ≈ºycia fali ‚Äì wywo≈Çujemy animacje odbiƒá
                if (timeToObserver <= WAVE_LIFETIME * 0.15) {
                    // Odbicie fali 2D ‚Äì efekt wizualny "na obserwatorze"
                    schedule2DReflection(observerX, xPosition, timestamp);
                    // Odbicie fali 1D/sto≈ºkowe (bardziej zaawansowana animacja)
                    scheduleReflectedWave(observerX, xPosition, timestamp, null, false);
                }
            }
        }

        // Tworzy i animuje falƒô odbitƒÖ (np. odbicie od obserwatora albo sto≈ºka Macha)
        function createReflectedWave(xPosition, timestamp, isShockwave = false, edgeX = null) {
            // Je≈ºeli pojazd to odrzutowiec lub pocisk, to odbicie pojawia siƒô na pozycji obserwatora
            let leftPosition;
            let topPosition;

            if (currentType === "jet" || currentType === "missile") {
                // U≈ºyj pozycji obserwatora
                leftPosition = observerX;
                topPosition = observer.style.top;
            } else {
                // Domy≈õlnie: dla shockwave edgeX, w pozosta≈Çych przypadkach xPosition
                leftPosition = isShockwave ? edgeX : xPosition;
            }

            // Tworzymy nowy element reprezentujƒÖcy falƒô odbitƒÖ
            const wave = document.createElement("div");
            wave.classList.add("wave-reflected"); // Nadajemy klasƒô odpowiedzialnƒÖ za styl odbitej fali

            // Je≈õli fala ma byƒá sto≈ºkiem Macha (shockwave)
            if (isShockwave) {
                wave.classList.add("shockwave"); // Dodatkowy styl (np. czerwona granica)
                wave.style.width = "1rem";       // Ustaw szeroko≈õƒá sto≈ºka Macha (rem = jednostka font-size)
                wave.style.height = "1rem";      // Ustaw wysoko≈õƒá sto≈ºka Macha
            }

            // Ustaw pozycjƒô X na wyliczonƒÖ powy≈ºej
            wave.style.left = `${leftPosition}%`;
            // Zawsze pozycja pionowa ≈õrodka
            wave.style.top = `${topPosition}`;

            // Przesuniƒôcie X zale≈ºy od tego, czy prƒôdko≈õƒá jest nadd≈∫wiƒôkowa ‚Äì inny efekt dla shockwave
            const translateX =
                speed >= SPEED_OF_SOUND
                    ? -(20 + (20 * speed) / SPEED_OF_SOUND)    // dla nadd≈∫wiƒôkowych ‚Äì mniejszy przesuw, fala bli≈ºej ≈∫r√≥d≈Ça
                    : -(50 + (50 * speed) / SPEED_OF_SOUND);   // dla podd≈∫wiƒôkowych ‚Äì wiƒôkszy przesuw za ≈∫r√≥d≈Çem
            wave.style.transform = `translate(${translateX}%, -50%)`;

            // Dodaj falƒô do g≈Ç√≥wnego kontenera animacji
            container.appendChild(wave);

            // Dodaj nowƒÖ falƒô do listy aktualnych fal (przydaje siƒô do czyszczenia animacji)
            waves.push({
                element: wave,
                xPosition: leftPosition,
                createdAt: timestamp / 1000, // czas powstania (sekundy)
            });

            // Usu≈Ñ falƒô z DOM i z listy fal po zako≈Ñczeniu animacji (czas ≈ºycia)
            setTimeout(() => {
                wave.remove();
                waves = waves.filter((w) => w.element !== wave);
            }, WAVE_LIFETIME * 1000);
        }



        /**
         * Planuje pojawienie siƒô fali odbitej (np. od obserwatora albo od sto≈ºka Macha) po up≈Çywie czasu,
         * kt√≥ry odpowiada dotarciu fali z pozycji wavePos do pozycji observerPos przy prƒôdko≈õci d≈∫wiƒôku.
         * - Je≈õli to shockwave (fala sto≈ºka Macha) ‚Äì pojawia siƒô natychmiast (delay 0).
         * - Dla zwyk≈Çych fal odbitych ‚Äì op√≥≈∫nienie zale≈ºne od dystansu.
         * Tworzy timeout, po kt√≥rym wywo≈Çuje createReflectedWave() (rysuje odbitƒÖ falƒô na scenie).
         * Timeout jest zapisywany do tablicy reflectedWaveTimeouts, ≈ºeby p√≥≈∫niej mo≈ºna by≈Ço go anulowaƒá.
         */
        function scheduleReflectedWave(observerPos, wavePos, timestamp, edgeX = null, isShockwave = false) {
            let delaySeconds;
            if (isShockwave) {
                delaySeconds = 0;
                // Je≈õli to fala sto≈ºka Macha ‚Äì pojawia siƒô od razu.
            } else {
                const distanceMeters = Math.abs(observerPos - wavePos) * METERS_PER_PERCENT;
                delaySeconds = distanceMeters / SPEED_OF_SOUND;
                // Dla zwyk≈Çej fali odbitej ‚Äì czekamy tyle czasu, ile zajmuje d≈∫wiƒôkowi przebycie dystansu do obserwatora.
            }
            const timeoutId = setTimeout(() => {
                createReflectedWave(observerPos, performance.now(), isShockwave, edgeX);
                // Po up≈Çywie czasu tworzymy odbitƒÖ falƒô w odpowiednim miejscu.
            }, delaySeconds * 1000);
            reflectedWaveTimeouts.push(timeoutId);
            // Dodajemy identyfikator timeoutu do listy (do ewentualnego p√≥≈∫niejszego czyszczenia).
        }

        /**
         * Usuwa wszystkie zaplanowane timeouty dla odbitych fal (zar√≥wno 1D jak i 2D) i czy≈õci listƒô timeout√≥w.
         * Dodatkowo usuwa wszystkie elementy fal odbitych z DOM.
         * U≈ºywane zawsze wtedy, gdy resetujemy symulacjƒô, zmieniamy parametry lub czy≈õcimy ekran.
         */
        function clearReflectedWaves() {
            reflectedWaveTimeouts.forEach((id) => clearTimeout(id));
            reflectedWaveTimeouts = [];
            // Usuwa i czy≈õci wszystkie timeouty zwyk≈Çych odbitych fal.
            reflection2DTimeouts.forEach((id) => clearTimeout(id));
            reflection2DTimeouts = [];
            // Usuwa i czy≈õci timeouty dla odbiƒá 2D.

            document.querySelectorAll(".wave-reflected, .wave-reflected-2d").forEach((el) => el.remove());
            // Usuwa wszystkie elementy odpowiadajƒÖce odbitym falom z DOM.
        }

        // Obs≈Çuguje zmianƒô prƒôdko≈õci przez suwak ‚Äì przepisuje prƒôdko≈õƒá, czy≈õci typ pojazdu,
        // od≈õwie≈ºa wy≈õwietlanie parametr√≥w, czy≈õci wszystkie odbite fale i ewentualny sto≈ºek Macha.
        speedControl.addEventListener("input", () => {
            speed = parseFloat(speedControl.value) || 0;
            console.debug(`Nowa prƒôdko≈õƒá: ${speed.toFixed(2)} m/s, currentType: ${currentType}`);
            currentType = null;
            updateSpeedDisplay();
            clearReflectedWaves();
            const existingCone = document.querySelector(".mach-cone");
            if (existingCone) existingCone.remove();
        });

        // Obs≈Çuguje zmianƒô czƒôstotliwo≈õci przez suwak ‚Äì ustawia flagƒô ‚Äûustawiane rƒôcznie‚Äù, aktualizuje warto≈õƒá,
        // od≈õwie≈ºa wy≈õwietlanie parametr√≥w i czy≈õci wszystkie odbite fale.
        frequencyControl.addEventListener("input", () => {
            isFrequencyManual = true;
            sourceFrequency = parseFloat(frequencyControl.value) || 1;
            updateFrequencyDisplay();
            clearReflectedWaves();
        });

        /**
         * Aktualizuje panel z dodatkowymi parametrami efektu Dopplera ‚Äì wy≈õwietla szczeg√≥≈Çowe dane fizyczne
         * na podstawie aktualnych ustawie≈Ñ i pozycji symulacji (np. przesuniƒôcie czƒôstotliwo≈õci, czas dotarcia fali, energia).
         * Wyniki prezentuje w elemencie HTML #dopplerDetails.
         */
        function updateDopplerDetails() {
            // Oblicza d≈Çugo≈õƒá fali lambda (Œª = v / f)
            let lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);

            // Je≈õli freqObserver jest liczbƒÖ (nie null) ‚Äì przypisz jƒÖ do freqObserverNum, inaczej null
            let freqObserverNum = typeof freqObserver === "number" ? freqObserver : null;

            // Oblicza przesuniƒôcie czƒôstotliwo≈õci (Œîf = fo - fz), je≈õli mamy warto≈õƒá obserwowanƒÖ
            let deltaF = freqObserverNum !== null ? freqObserverNum - sourceFrequency : null;

            // Oblicza wsp√≥≈Çczynnik Dopplera (fo/fz), je≈õli mamy warto≈õƒá obserwowanƒÖ
            let dopplerCoeff = freqObserverNum !== null ? freqObserverNum / sourceFrequency : null;

            // Dystans procentowy (procentowa odleg≈Ço≈õƒá na osi X miƒôdzy obserwatorem a ≈∫r√≥d≈Çem)
            let distancePercent = Math.abs(observerX - sourceX);

            // Przelicza dystans procentowy na metry
            let distanceMeters = distancePercent * METERS_PER_PERCENT;

            // Czas dotarcia fali do obserwatora (t = d / v)
            let timeToObserver = distanceMeters / SPEED_OF_SOUND;

            // (Zaawansowane, tylko do podglƒÖdu): czas dotarcia w procentowej symulacji (uwzglƒôdnia skalƒô)
            let timeToObserverPercent;
            if (speed < SPEED_OF_SOUND) {
                // Podd≈∫wiƒôkowe: czas = dystans / prƒôdko≈õƒá symulowanego d≈∫wiƒôku
                timeToObserverPercent = distancePercent / SPEED_OF_SOUND_SIM;
            } else {
                // Nadd≈∫wiƒôkowe: uwzglƒôdnia r√≥≈ºnicƒô prƒôdko≈õci ≈∫r√≥d≈Ça i d≈∫wiƒôku (≈ºeby nie dzieliƒá przez zero)
                const speedSim = (speed / SPEED_OF_SOUND) * SPEED_OF_SOUND_SIM;
                timeToObserverPercent = distancePercent / Math.max(speedSim - SPEED_OF_SOUND_SIM, 0.001);
            }

            // Przesuniƒôcie fazowe: ŒîœÜ = 2œÄ * d / Œª (w radianach)
            let phaseShift = (2 * Math.PI * distanceMeters) / (lambda > 0 ? lambda : 1);

            // Energia fali przy obserwatorze, proporcjonalnie do 1/d¬≤
            let energyAtObs = 1 / Math.pow(distanceMeters || 1, 2);

            // Czy czƒôstotliwo≈õƒá jest s≈Çyszalna dla cz≈Çowieka (20 Hz ‚Äì 20 000 Hz)
            let isAudible = sourceFrequency >= 20 && sourceFrequency <= 20000;

            // Liczba czo≈Çowych fal na sekundƒô (czƒôstotliwo≈õƒá)
            let wavefrontsPerSecond = sourceFrequency;

            // Wy≈õwietla wszystko w panelu #dopplerDetails
            document.getElementById("dopplerDetails").innerHTML = `
                <b>Dodatkowe parametry:</b><br>
                Przesuniƒôcie Dopplera Œîf: ${deltaF !== null ? deltaF.toFixed(2) + " Hz" : "‚Äî"}<br>
                Wsp√≥≈Çczynnik Dopplera: ${dopplerCoeff !== null ? dopplerCoeff.toFixed(3) : "‚Äî"}<br>
                Czas dotarcia fali: ${timeToObserver.toFixed(3)} s<br>
                Przesuniƒôcie fazowe: ${phaseShift.toFixed(2)} rad<br>
                Energia wzglƒôdna: ${energyAtObs.toExponential(2)}<br>
                S≈Çyszalno≈õƒá: ${isAudible ? "TAK" : "NIE"}<br>
            `;
        }


        /**
         * Aktualizuje panel boczny oraz wy≈õwietlacz prƒôdko≈õci na podstawie aktualnego stanu symulacji.
         * Pokazuje podstawowe fizyczne parametry: prƒôdko≈õƒá, liczbƒô Macha, czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça, d≈Çugo≈õƒá fali,
         * czƒôstotliwo≈õƒá obserwatora (z efektem Dopplera), kƒÖt sto≈ºka Macha (je≈õli prƒôdko≈õƒá nadd≈∫wiƒôkowa)
         * oraz po≈Ço≈ºenie ≈∫r√≥d≈Ça wzglƒôdem obserwatora. Dodatkowo wywo≈Çuje updateDopplerDetails().
         */
        function updateSpeedDisplay() {
            // Przelicza prƒôdko≈õƒá z m/s na km/h i mph
            const kmh = speed * 3.6;
            const mph = speed * 2.23694;
            let lambda, machAngleDeg, machAngleRad;
            try {
                // Oblicza d≈Çugo≈õƒá fali na podstawie czƒôstotliwo≈õci i prƒôdko≈õci d≈∫wiƒôku
                lambda = countWaveLength(sourceFrequency, SPEED_OF_SOUND);

                // Oblicza liczbƒô Macha (ile razy prƒôdko≈õƒá przekracza prƒôdko≈õƒá d≈∫wiƒôku)
                const mach = speed / SPEED_OF_SOUND;

                // Oblicza czƒôstotliwo≈õƒá obserwowanƒÖ z efektem Dopplera
                freqObserver = dopplerFrequencySound(
                    sourceFrequency,
                    SPEED_OF_SOUND,
                    sourceX < observerX ? speed : -speed, // znak zale≈ºny od po≈Ço≈ºenia
                    0
                );

                // Dla prƒôdko≈õci podd≈∫wiƒôkowych nie liczymy kƒÖta sto≈ºka Macha
                if (speed < SPEED_OF_SOUND) {
                    machAngleDeg = "-";
                    machAngleRad = "-";
                } else {
                    // Dla nadd≈∫wiƒôkowych: oblicz kƒÖt sto≈ºka Macha w radianach i stopniach
                    const theta = Math.asin(SPEED_OF_SOUND / speed);
                    machAngleRad = theta;
                    machAngleDeg = theta * (180 / Math.PI);
                }

                // Oblicza dystans (procentowo) pomiƒôdzy ≈∫r√≥d≈Çem a obserwatorem na osi X
                const distance = sourceX - observerX;
                let distanceText;
                if (distance < 0) {
                    distanceText = `PRZED obserwatorem (${distance.toFixed(2)}%)`;
                } else if (distance > 0) {
                    distanceText = `ZA obserwatorem (+${distance.toFixed(2)}%)`;
                } else {
                    distanceText = "Na obserwatorze (0%)";
                }

                // Ustawia tekst zaktualizowanej prƒôdko≈õci w panelu
                speedDisplay.textContent = speed.toFixed(2);

                // Tworzy i wy≈õwietla szczeg√≥≈Çowy panel z g≈Ç√≥wnymi parametrami fizycznymi
                speedDetails.innerHTML = `
                        <b> G≈Ç√≥wne parametry: </b><br>
                        Prƒôdko≈õƒá: ${speed.toFixed(2)} m/s | ${kmh.toFixed(2)} km/h | ${mph.toFixed(2)} mph<br>
                        Liczba Macha: ${mach.toFixed(2)}<br>
                        Czƒôstotliwo≈õƒá ≈∫r√≥d≈Ça: ${sourceFrequency.toFixed(1)} Hz<br>
                        D≈Çugo≈õƒá fali: ${lambda.toFixed(2)} m<br>
                        Czƒôstotliwo≈õƒá obserwatora (x=${observerX.toFixed(3)}%): ${typeof freqObserver === "number"
                        ? freqObserver.toFixed(1) + " Hz"
                        : freqObserver
                    }<br>
                        KƒÖt sto≈ºka Macha: ${machAngleDeg !== "-"
                        ? machAngleDeg.toFixed(2) + "¬∞ / " + machAngleRad.toFixed(3) + " rad"
                        : "‚Äî (pod≈õwietlenie dla podd≈∫wiƒôkowych)"
                    }
                        <br>
                        <b>Odleg≈Ço≈õƒá od obserwatora: ${distanceText}</b>
                    `;

                // Aktualizuje dodatkowe szczeg√≥≈Çy Dopplera (panel poni≈ºej)
                updateDopplerDetails();
            } catch (error) {
                // Loguje b≈ÇƒÖd, gdyby co≈õ posz≈Ço nie tak w obliczeniach
                console.error("B≈ÇƒÖd w updateSpeedDisplay:", error);
            }
        }


        /**
         * Aktualizuje wy≈õwietlacz czƒôstotliwo≈õci w panelu sterowania oraz od≈õwie≈ºa panel parametr√≥w prƒôdko≈õci.
         * - Wywo≈Çywana za ka≈ºdym razem, gdy zmienisz warto≈õƒá suwaka czƒôstotliwo≈õci.
         * - Pokazuje warto≈õƒá z dok≈Çadno≈õciƒÖ do 1 miejsca po przecinku.
         * - Uwaga: r√≥wnie≈º wywo≈Çuje updateSpeedDisplay(), wiƒôc ca≈Ço≈õƒá panelu jest aktualizowana.
         */
        function updateFrequencyDisplay() {
            frequencyDisplay.textContent = sourceFrequency.toFixed(2);
            updateSpeedDisplay();
        }

        /**
         * Tworzy sto≈ºek Macha dla obiekt√≥w nadd≈∫wiƒôkowych (jet/missile).
         * - Sprawdza, czy istnieje ju≈º sto≈ºek Macha w DOM (klasa .mach-cone) i usuwa go, ≈ºeby nie by≈Ço duplikat√≥w.
         * - Je≈ºeli prƒôdko≈õƒá jest podd≈∫wiƒôkowa lub typ nie jest 'jet'/'missile', funkcja ko≈Ñczy dzia≈Çanie (nie rysuje sto≈ºka).
         * - Oblicza kƒÖt sto≈ºka Macha (asin(1/M)), szeroko≈õƒá oraz wysoko≈õƒá sto≈ºka w jednostkach procentowych.
         * - Wylicza czƒôstotliwo≈õƒá zeskalowanƒÖ (do optymalizacji), na tej podstawie okre≈õla, jak czƒôsto generowaƒá nowe fale w sto≈ºku.
         * - Gdy up≈ÇynƒÖ≈Ç odpowiedni czas od ostatniej fali (zgodnie z okresowo≈õciƒÖ czƒôstotliwo≈õci), tworzy nowƒÖ falƒô createWave().
         * - Aktualizuje znacznik czasu ostatniej generacji fali.
         */
        function createMachCone(timestamp) {
            const existingCone = document.querySelector(".mach-cone");
            if (existingCone) existingCone.remove();

            // Je≈ºeli prƒôdko≈õƒá < prƒôdko≈õci d≈∫wiƒôku lub typ to nie jet/missile ‚Äì nic nie r√≥b
            if (speed < SPEED_OF_SOUND || (currentType !== "jet" && currentType !== "missile")) {
                const existingCone = document.querySelector(".mach-cone");
                if (existingCone) existingCone.remove();
                return;
            }

            // Oblicza kƒÖt sto≈ºka Macha (w stopniach)
            const machAngle = Math.asin(SPEED_OF_SOUND / speed) * (180 / Math.PI);

            // Ustal szeroko≈õƒá sto≈ºka Macha (w procentach kontenera)
            const coneWidth = CONE_WIDTH_PERCENT;
            // Wylicza wysoko≈õƒá sto≈ºka (geometria tr√≥jkƒÖta na podstawie kƒÖta)
            const coneHeight = Math.tan(machAngle * (Math.PI / 180)) * (coneWidth / 2);

            // Zeskalowana czƒôstotliwo≈õƒá (w symulacji liczba fal jest mniejsza ni≈º w rzeczywisto≈õci)
            const scaledFrequency = sourceFrequency / FREQUENCY_SCALE_FACTOR;
            // Oblicza okres generowania fal na podstawie zeskalowanej czƒôstotliwo≈õci
            const period = 1 / scaledFrequency;
            // Je≈õli minƒÖ≈Ç odpowiedni czas od ostatniej fali, generuje nowƒÖ falƒô (symulacja emisji przez odrzutowiec)
            if (timestamp / 1000 - lastWaveTime >= period) {
                createWave(sourceX, timestamp);
                lastWaveTime = timestamp / 1000;
            }
        }

        /**
         * Tworzy tymczasowy znacznik (marker) na osi symulacji w celu debugowania.
         * - S≈Çu≈ºy do pod≈õwietlania konkretnej pozycji na osi X (np. krawƒôd≈∫ sto≈ºka Macha, miejsce wykrycia czego≈õ wa≈ºnego).
         * - Zawsze pojawia siƒô dok≈Çadnie na podanej pozycji procentowej xPosition oraz na ≈õrodku osi Y (50%).
         * - Marker automatycznie znika po 1 sekundzie.
         */
        function createDebugMarker(xPosition) {
            // Usuwa poprzedni marker, je≈õli jeszcze istnieje, ≈ºeby nie by≈Ço wiƒôcej ni≈º jednego naraz
            const existingMarker = document.querySelector(".debug-marker");
            if (existingMarker) existingMarker.remove();

            // Tworzy nowy znacznik <div> i nadaje mu klasƒô do stylowania (np. czerwona kropka)
            const marker = document.createElement("div");
            marker.classList.add("debug-marker");

            // Ustawia pozycjƒô markera na osi X (procent kontenera) oraz na ≈õrodku osi Y (50%)
            marker.style.left = `${xPosition}%`;
            marker.style.top = "50%";
            marker.style.transform = "translate(-50%, -50%)"; // Wy≈õrodkowanie markera wzglƒôdem punktu

            // Dodaje znacznik do kontenera symulacji (g≈Ç√≥wnego obszaru animacji)
            container.appendChild(marker);

            // Po 1 sekundzie usuwa marker z DOM, ≈ºeby nie zostawa≈Çy ≈õmieci i nie za≈õmieca≈Çy ekranu
            setTimeout(() => {
                marker.remove();
            }, 1000);
        }

        /**
         * G≈Ç√≥wna pƒôtla animacji symulacji.
         * - Przesuwa ≈∫r√≥d≈Ço d≈∫wiƒôku (pojazd) na osi X.
         * - Prze≈ÇƒÖcza typ pojazdu na podstawie prƒôdko≈õci.
         * - Dostosowuje grafiki, parametry i d≈∫wiƒôki dla danego typu.
         * - Tworzy i animuje fale oraz sto≈ºki Macha.
         * - Wywo≈Çuje odtwarzanie d≈∫wiƒôk√≥w specjalnych (np. szokowy, jet).
         * - Aktualizuje wszystkie wizualizacje i parametry na ekranie.
         */
        function update(timestamp) {
            // Je≈õli symulacja jest zapauzowana, przerywamy pƒôtlƒô
            if (isPaused) return;

            // ---- 1. Ruch ≈∫r√≥d≈Ça d≈∫wiƒôku po osi X ----
            const deltaTime = 0.016; // Sta≈Ça przyrostu czasu (ok. 60 klatek/s)
            // Przesuwamy ≈∫r√≥d≈Ço proporcjonalnie do prƒôdko≈õci
            sourceX += (speed / SPEED_OF_SOUND) * deltaTime * 10 * SCALE_FACTOR;
            // Je≈õli dotarli≈õmy do ko≈Ñca skali (100%), zawijamy do poczƒÖtku (pƒôtla)
            if (sourceX > 100) {
                sourceX -= 100;
                lastShockwavePos = null;
                lastShockwaveTime = 0;
            }

            // Aktualizujemy pozycjƒô obrazka pojazdu na osi X
            if (movingDot) {
                movingDot.style.left = `${sourceX}%`;
            }

            // ---- 2. Wybieramy typ pojazdu na podstawie prƒôdko≈õci ----
            const isCarSpeed = speed <= 20;
            const isAmbulance = speed > 20 && speed <= 39;
            const isCarSport = speed > 50 && speed <= 117;
            const isJet = speed > 117 && speed < 664;
            const isMissile = speed >= 664;

            let newType = null;
            // Ustawiamy typ pojazdu, t≈Ço, pozycjƒô i rozmiar obserwatora
            if (isCarSpeed) {
                // Samoch√≥d
                document.body.style.backgroundImage = "url('./css/img/arizona_road.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundPosition = "0px -280px";
                document.body.style.backgroundColor = "#e6a142";
                newType = "car";
                observer.style.top = "45%";
                observer.style.height = "80px";
            } else if (isAmbulance) {
                // Ambulans
                document.body.style.backgroundImage = "url('./css/img/arizona_road.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundPosition = "0px -280px";
                document.body.style.backgroundColor = "#e6a142";
                newType = "ambulance";
                observer.style.top = "45%";
                observer.style.height = "80px";
            } else if (isCarSport) {
                // Samoch√≥d sportowy
                document.body.style.backgroundImage = "url('./css/img/arizona_road.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundRepeat = "no-repeat";
                document.body.style.backgroundPosition = "0px -280px";
                document.body.style.backgroundColor = "#e6a142";
                newType = "sport";
                observer.style.top = "45%";
                observer.style.height = "80px";
            } else if (isJet) {
                // Odrzutowiec
                document.body.style.backgroundImage = "url('./css/img/sky.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundPosition = "0px 180px";
                document.body.style.backgroundColor = "rgb(193, 255, 244)";
                newType = "jet";
                observer.style.top = "72%";
                observer.style.height = "35px";
            } else if (isMissile) {
                // Pocisk
                document.body.style.backgroundImage = "url('./css/img/sky.jpg')";
                document.body.style.backgroundSize = "cover";
                document.body.style.backgroundPosition = "0px 180px";
                document.body.style.backgroundColor = "rgb(193, 255, 244)";
                newType = "missile";
                observer.style.top = "72%";
                observer.style.height = "35px";
            }

            // ---- 3. Je≈õli zmieni≈Ç siƒô typ pojazdu: aktualizujemy grafiki i domy≈õlnƒÖ czƒôstotliwo≈õƒá ----
            if (newType !== currentType) {
                currentType = newType;

                if (newType === "car") {
                    movingDot.src = "./css/img/car_yellow.png";
                    observer.src = "./css/img/human.png";
                    movingDot.style.transform = `translate(-50%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 2500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "ambulance") {
                    movingDot.src = "./css/img/ambulance.png";
                    observer.src = "./css/img/nurse.png";
                    movingDot.style.transform = `translate(-50%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 2500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "sport") {
                    movingDot.src = "./css/img/bugatti_chiron.png";
                    observer.src = "./css/img/human.png";
                    movingDot.style.transform = `translate(-75%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 3500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "jet") {
                    movingDot.src = "./css/img/jet.png";
                    observer.src = "./css/img/human.png";
                    movingDot.style.transform = `translate(-100%, -50%)`;
                    if (!isFrequencyManual) {
                        sourceFrequency = 4500;
                        frequencyControl.value = sourceFrequency;
                    }
                } else if (newType === "missile") {
                    observer.src = "./css/img/human.png";
                    movingDot.src = "./css/img/missle.png";
                    movingDot.style.transform = `translate(-100%, -50%)`;
                }

                // Aktualizacja wy≈õwietlanej czƒôstotliwo≈õci
                updateFrequencyDisplay();
            }

            // ---- 4. Tworzenie fal (dla podd≈∫wiƒôkowych) ----
            const scaledFrequency = sourceFrequency / FREQUENCY_SCALE_FACTOR;
            const period = 1 / scaledFrequency;
            if (speed < SPEED_OF_SOUND && timestamp / 1000 - lastWaveTime >= period) {
                createWave(sourceX, timestamp);
                lastWaveTime = timestamp / 1000;
            }

            // ---- 5. Sto≈ºek Macha, d≈∫wiƒôk szokowy i marker na krawƒôdzi sto≈ºka (dla nadd≈∫wiƒôkowych jet/missile) ----
            const waveWidthPx = 0.95 * parseFloat(getComputedStyle(document.documentElement).fontSize);
            const proximityThreshold = (waveWidthPx / (container.clientWidth || 1000)) * 100 * 5;

            if (speed >= SPEED_OF_SOUND && (currentType === "jet" || currentType === "missile")) {
                // Zmieniamy szeroko≈õƒá grafiki samolotu
                movingDot.style.width = `220px`;
                movingDot.style.transform = `translate(-50%, -50%)`;

                // Obliczamy kƒÖt i krawƒôd≈∫ sto≈ºka Macha
                const machAngle = Math.asin(SPEED_OF_SOUND / speed);
                const coneWidthPercent = CONE_WIDTH_PERCENT;
                const edgeX = sourceX - coneWidthPercent * Math.cos(machAngle);
                createDebugMarker(edgeX); // Zaznaczamy miejsce krawƒôdzi sto≈ºka

                // Warunki na "uderzenie" sto≈ºka w obserwatora
                const shockThreshold = coneWidthPercent / 2;
                const currentTime = timestamp / 1000;
                const isConeEdgeAtObserver =
                    Math.abs(observerX - edgeX) < proximityThreshold &&
                    (!lastShockwavePos || Math.abs(sourceX - lastShockwavePos) > shockThreshold) &&
                    currentTime - lastShockwaveTime > MIN_SHOCKWAVE_INTERVAL;

                createMachCone(timestamp);      // Rysuje sto≈ºek Mach'a
                updateMachConeAndLines();       // Aktualizuje linie graficzne sto≈ºka

                // Efekt d≈∫wiƒôkowy i fala szokowa
                if (isConeEdgeAtObserver) {
                    scheduleReflectedWave(observerX, sourceX, timestamp, edgeX, true);
                    lastShockwavePos = sourceX;
                    lastShockwaveTime = currentTime;
                    playSound("./sounds/shockwave.mp3");
                }
            }

            // ---- 6. Odtwarzanie d≈∫wiƒôku jet (ponadd≈∫wiƒôkowy i podd≈∫wiƒôkowy) ----
            // Dla jet: gdy znajduje siƒô dok≈Çadnie -30% przed obserwatorem i jeszcze nie przekroczy≈Ç d≈∫wiƒôku
            if (
                currentType === "jet" &&
                Math.abs(sourceX - (observerX - 30)) < 0.5 && // ma≈Çy margines, animacja nie jest "skokowa"
                speed < SPEED_OF_SOUND
            ) {
                if (!window.jetSoundPlayed) { // Zapobiega wielokrotnemu odtwarzaniu
                    playSound("./sounds/jet.mp3");
                    window.jetSoundPlayed = true;
                }
            } else if (window.jetSoundPlayed) {
                window.jetSoundPlayed = false; // Reset, je≈õli jet oddali siƒô od tej pozycji
            }

            // Dla jet: gdy dok≈Çadnie na obserwatorze (dla nadd≈∫wiƒôkowego) ‚Äî¬†mo≈ºesz zmieniƒá warunek wg uznania
            if (
                currentType === "jet" &&
                Math.abs(sourceX - (observerX)) < 0.5 &&
                speed >= SPEED_OF_SOUND
            ) {
                if (!window.jetSoundPlayed) {
                    playSound("./sounds/jet.mp3");
                    window.jetSoundPlayed = true;
                }
            } else if (window.jetSoundPlayed) {
                window.jetSoundPlayed = false;
            }

            // ---- 7. Kontynuacja pƒôtli animacji ----
            requestAnimationFrame(update); // Wywo≈Çuje kolejnƒÖ klatkƒô

            // ---- 8. Aktualizacje wizualizacji i d≈∫wiƒôku silnika ----
            updateMachConeAndLines();
            updateSpeedDisplay();
            updateEngineSound(currentType, sourceX, observerX, speed);

        }

        /**
         * Funkcja makePanelDraggable(panel, handle)
         * Umo≈ºliwia przeciƒÖganie dowolnego panelu (np. bocznego okienka z wynikami) po ekranie
         * poprzez klikniƒôcie i przeciƒÖgniƒôcie za okre≈õlony uchwyt (handle).
         * 
         * - panel: element DOM, kt√≥ry chcemy przesuwaƒá po ekranie
         * - handle: element DOM, kt√≥ry s≈Çu≈ºy jako uchwyt do przeciƒÖgania panelu
         * 
         * Po klikniƒôciu uchwytu (handle), panel ≈õledzi ruchy myszy
         * i zmienia swoje po≈Ço≈ºenie na ekranie, dop√≥ki nie puszczymy przycisku myszy.
         */

        function makePanelDraggable(panel, handle) {
            // Pozycja kursora wzglƒôdem panelu przy rozpoczƒôciu przeciƒÖgania
            let offsetX = 0,
                offsetY = 0,
                isDown = false; // Czy aktualnie przeciƒÖgamy panel

            // Gdy u≈ºytkownik kliknie uchwyt (handle), zapamiƒôtaj, gdzie kliknƒÖ≈Ç wzglƒôdem panelu
            handle.addEventListener("mousedown", function (e) {
                isDown = true;
                offsetX = e.clientX - panel.offsetLeft;
                offsetY = e.clientY - panel.offsetTop;
                document.body.style.cursor = "grabbing"; // Wizualny efekt chwytania
                e.preventDefault(); // Nie zaznaczaj tekstu itp.
            });

            // Gdy u≈ºytkownik porusza myszƒÖ, a panel jest "z≈Çapany" (isDown), przesuwaj panel zgodnie z ruchem myszy
            document.addEventListener("mousemove", function (e) {
                if (!isDown) return; // Nie przesuwaj, je≈õli nie trzymamy myszy
                panel.style.left = e.clientX - offsetX + "px"; // Nowa pozycja X panelu
                panel.style.top = e.clientY - offsetY + "px";  // Nowa pozycja Y panelu
            });

            // Po puszczeniu przycisku myszy przesta≈Ñ przeciƒÖgaƒá panel
            document.addEventListener("mouseup", function () {
                isDown = false;
                document.body.style.cursor = ""; // Przywr√≥ƒá domy≈õlny kursor
            });
        }

        // Ten blok kodu wykonuje siƒô, gdy ca≈Ça zawarto≈õƒá DOM (HTML) jest ju≈º wczytana i gotowa do pracy
        window.addEventListener("DOMContentLoaded", () => {

            // Obs≈Çuga przycisku "START" ‚Äì¬†wznowienie animacji
            document.getElementById("startBtn").addEventListener("click", () => {
                if (isPaused) {
                    isPaused = false;                  // Zmienna globalna: czy symulacja zatrzymana
                    requestAnimationFrame(update);     // Wznawia g≈Ç√≥wnƒÖ pƒôtlƒô animacji
                }
            });

            // Obs≈Çuga przycisku "PAUZA" ‚Äì zatrzymanie animacji (nie usuwa stanu)
            document.getElementById("pauseBtn").addEventListener("click", () => {
                isPaused = true;
            });

            // Obs≈Çuga przycisku "RESET" ‚Äì prze≈Çadowanie strony (reset wszystkiego do stanu poczƒÖtkowego)
            document.getElementById("resetBtn").addEventListener("click", () => {
                location.reload();
            });

            // Ustaw pozycjƒô obserwatora (postaƒá cz≈Çowieka) na osi symulacji na start (50%)
            observer.style.left = observerX + "%";

            // Zaktualizuj wy≈õwietlane warto≈õci prƒôdko≈õci i czƒôstotliwo≈õci na panelu
            updateDisplays();

            // Dodaj event listener do suwaka prƒôdko≈õci ‚Äì aktualizuje warto≈õci na panelu
            speedControl.addEventListener("input", updateDisplays);
            // Dodaj event listener do suwaka czƒôstotliwo≈õci ‚Äì to samo
            frequencyControl.addEventListener("input", updateDisplays);

            // Od razu zaktualizuj panele ze szczeg√≥≈Çami
            updateSpeedDisplay();
            updateFrequencyDisplay();
            requestAnimationFrame(update); // Rozpocznij g≈Ç√≥wnƒÖ animacjƒô od razu po starcie
            updateEngineSound(currentType, sourceX, observerX, speed);

            // --- Poni≈ºej obs≈Çuga przeciƒÖgania ≈∫r√≥d≈Ça d≈∫wiƒôku (movingDot ‚Äì samoch√≥d, samolot, itp.) ---

            let isDragging = false;
            let offsetX = 0;

            // Po naci≈õniƒôciu na ≈∫r√≥d≈Ço d≈∫wiƒôku (np. samoch√≥d) zapamiƒôtaj przesuniƒôcie kursora wzglƒôdem ≈õrodka obrazka
            movingDot.addEventListener("mousedown", (e) => {
                isDragging = true;
                const rect = movingDot.getBoundingClientRect();
                offsetX = e.clientX - (rect.left + rect.width / 2);
                document.body.style.cursor = "grabbing";
                e.preventDefault();
            });

            // Gdy przesuwamy mysz, a ≈∫r√≥d≈Ço jest "z≈Çapane", przesu≈Ñ ≈∫r√≥d≈Ço d≈∫wiƒôku po osi X symulacji
            window.addEventListener("mousemove", (e) => {
                if (!isDragging) return;
                const containerRect = container.getBoundingClientRect();
                let x = e.clientX - containerRect.left - offsetX;
                x = Math.max(0, Math.min(x, containerRect.width)); // Ogranicz do szeroko≈õci kontenera
                const percent = (x / containerRect.width) * 100;
                movingDot.style.left = percent + "%";
                sourceX = percent; // Nowa pozycja ≈∫r√≥d≈Ça d≈∫wiƒôku
                clearReflectedWaves();       // Czy≈õƒá stare fale odbite
                updateMachConeAndLines();    // Aktualizuj wizualizacjƒô sto≈ºka Macha
                updateSpeedDisplay();        // Aktualizuj panel boczny
            });

            // Po puszczeniu myszy ‚Äì¬†przesta≈Ñ przesuwaƒá ≈∫r√≥d≈Ço, przywr√≥ƒá kursor
            window.addEventListener("mouseup", (e) => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "";
                }
            });

            // --- Obs≈Çuga przeciƒÖgania obserwatora (postaƒá cz≈Çowieka) ---
            let isDraggingObserver = false;
            let observerOffsetX = 0;

            // Analogicznie jak dla ≈∫r√≥d≈Ça ‚Äì z≈Çap obserwatora (myszka na ikonie cz≈Çowieka)
            observer.addEventListener("mousedown", (e) => {
                isDraggingObserver = true;
                const rect = observer.getBoundingClientRect();
                observerOffsetX = e.clientX - (rect.left + rect.width / 2);
                document.body.style.cursor = "grabbing";
                clearReflectedWaves();
                e.preventDefault();
            });

            // PrzeciƒÖganie obserwatora po osi X
            window.addEventListener("mousemove", (e) => {
                if (isDraggingObserver) {
                    const containerRect = container.getBoundingClientRect();
                    let x = e.clientX - containerRect.left - observerOffsetX;
                    x = Math.max(0, Math.min(x, containerRect.width));
                    const percent = (x / containerRect.width) * 100;
                    observer.style.left = percent + "%";
                    observerX = percent;   // Nowa pozycja obserwatora
                    clearReflectedWaves();
                    updateMachConeAndLines();
                    updateSpeedDisplay();
                }
            });

            // Po puszczeniu myszy przesta≈Ñ przesuwaƒá obserwatora, przywr√≥ƒá kursor
            window.addEventListener("mouseup", (e) => {
                if (isDraggingObserver) {
                    isDraggingObserver = false;
                    document.body.style.cursor = "";
                }
            });

            // --- Ustawianie paneli bocznych jako przeciƒÖgalne (drag&drop) przez ca≈Çy ich obszar ---
            makePanelDraggable(document.getElementById("speedDetails"), document.getElementById("speedDetails"));
            makePanelDraggable(document.getElementById("dopplerDetails"), document.getElementById("dopplerDetails"));

            // Panel sterowania mo≈ºna przesuwaƒá za dedykowany uchwyt ("controls-handle")
            makePanelDraggable(document.getElementById("controls"), document.getElementById("controls-handle"));

            const tbody = document.getElementById("results-table-body");

            // --- Obs≈Çuga przycisku "Poka≈º wyniki" (modal z tabelƒÖ) ---
            document.getElementById("show-results-btn").addEventListener("click", showResultsModal);

            // Zamknij modal po klikniƒôciu X
            document.getElementById("close-btn").addEventListener("click", () => {
                const modal = document.getElementById("results-modal");
                modal.style.display = "none";
            });

            // Zamknij modal po klikniƒôciu poza jego obszar (poza okienko)
            window.addEventListener("click", (e) => {
                const modal = document.getElementById("results-modal");
                if (e.target === modal) modal.style.display = "none";
            });
        });

        // Zabezpieczenie przed przypadkowym skalowaniem strony (zoom) podczas przewijania z wci≈õniƒôtym Ctrl
        window.addEventListener(
            "wheel",                // Nas≈Çuchuj ka≈ºdego obrotu k√≥≈Çkiem myszy
            function (e) {
                if (e.ctrlKey) {    // Je≈ºeli u≈ºytkownik trzyma wci≈õniƒôty klawisz Ctrl podczas scrollowania
                    e.preventDefault();  // Zablokuj domy≈õlnƒÖ akcjƒô (czyli powiƒôkszanie/zmniejszanie strony)
                }
            },
            { passive: false }      // Pozw√≥l na wywo≈Çanie e.preventDefault() (bez tego opcja jest ignorowana)
        );

    </script>
</body>

</html>